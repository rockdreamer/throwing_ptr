<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>throwing_ptr: throwing::shared_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">throwing_ptr
   </div>
   <div id="projectbrief">Smart pointers that throw on dereference if null</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacethrowing.html">throwing</a></li><li class="navelem"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classthrowing_1_1shared__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">throwing::shared_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced.  
 <a href="classthrowing_1_1shared__ptr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ae00f4f07e98dbb7c5d3cee41c95ca2"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a></td></tr>
<tr class="memdesc:a5ae00f4f07e98dbb7c5d3cee41c95ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type pointed to.  <a href="#a5ae00f4f07e98dbb7c5d3cee41c95ca2">More...</a><br /></td></tr>
<tr class="separator:a5ae00f4f07e98dbb7c5d3cee41c95ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa56578e272392918e0f6100fa68b0460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa56578e272392918e0f6100fa68b0460">shared_ptr</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a>=default</td></tr>
<tr class="memdesc:aa56578e272392918e0f6100fa68b0460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>.  <a href="#aa56578e272392918e0f6100fa68b0460">More...</a><br /></td></tr>
<tr class="separator:aa56578e272392918e0f6100fa68b0460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280413aaeec3ea76a49386400b784d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a280413aaeec3ea76a49386400b784d22">shared_ptr</a> (std::nullptr_t ptr) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a280413aaeec3ea76a49386400b784d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>.  <a href="#a280413aaeec3ea76a49386400b784d22">More...</a><br /></td></tr>
<tr class="separator:a280413aaeec3ea76a49386400b784d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f771212443dfc2a6ec4e9d81105597b"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a7f771212443dfc2a6ec4e9d81105597b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a7f771212443dfc2a6ec4e9d81105597b">shared_ptr</a> (Y *ptr)</td></tr>
<tr class="memdesc:a7f771212443dfc2a6ec4e9d81105597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#a7f771212443dfc2a6ec4e9d81105597b">More...</a><br /></td></tr>
<tr class="separator:a7f771212443dfc2a6ec4e9d81105597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa7cf8abd4690a05a51fad4422a7e2c10">shared_ptr</a> (Y *ptr, Deleter d)</td></tr>
<tr class="memdesc:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#aa7cf8abd4690a05a51fad4422a7e2c10">More...</a><br /></td></tr>
<tr class="separator:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e456cc2d34c98692a85af139a6b6ab"><td class="memTemplParams" colspan="2">template&lt;class Deleter &gt; </td></tr>
<tr class="memitem:a23e456cc2d34c98692a85af139a6b6ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a23e456cc2d34c98692a85af139a6b6ab">shared_ptr</a> (std::nullptr_t ptr, Deleter d)</td></tr>
<tr class="memdesc:a23e456cc2d34c98692a85af139a6b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#a23e456cc2d34c98692a85af139a6b6ab">More...</a><br /></td></tr>
<tr class="separator:a23e456cc2d34c98692a85af139a6b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter , class Alloc &gt; </td></tr>
<tr class="memitem:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab2ea12ca9c62996c9bea2cfae44cee0a">shared_ptr</a> (Y *ptr, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#ab2ea12ca9c62996c9bea2cfae44cee0a">More...</a><br /></td></tr>
<tr class="separator:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfb374e4475de66502cb266a09a4722"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:afdfb374e4475de66502cb266a09a4722"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#afdfb374e4475de66502cb266a09a4722">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r, <a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *ptr) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:afdfb374e4475de66502cb266a09a4722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aliasing constructor.  <a href="#afdfb374e4475de66502cb266a09a4722">More...</a><br /></td></tr>
<tr class="separator:afdfb374e4475de66502cb266a09a4722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af209003d1d20bb8b0b732d92011812b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#af209003d1d20bb8b0b732d92011812b0">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:af209003d1d20bb8b0b732d92011812b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#af209003d1d20bb8b0b732d92011812b0">More...</a><br /></td></tr>
<tr class="separator:af209003d1d20bb8b0b732d92011812b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a6002b7b79c7e6a7eccc7bc10c350ba99">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#a6002b7b79c7e6a7eccc7bc10c350ba99">More...</a><br /></td></tr>
<tr class="separator:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#adc732d6edcc4ac98d17ab2d95ac02fa5">shared_ptr</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r.  <a href="#adc732d6edcc4ac98d17ab2d95ac02fa5">More...</a><br /></td></tr>
<tr class="separator:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e386182530e963bb27d04aea3cf3f3"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a38e386182530e963bb27d04aea3cf3f3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a38e386182530e963bb27d04aea3cf3f3">shared_ptr</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38e386182530e963bb27d04aea3cf3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r.  <a href="#a38e386182530e963bb27d04aea3cf3f3">More...</a><br /></td></tr>
<tr class="separator:a38e386182530e963bb27d04aea3cf3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab275cec979cdef3a044bbd2440c1c40b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab275cec979cdef3a044bbd2440c1c40b">shared_ptr</a> (const std::shared_ptr&lt; T &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab275cec979cdef3a044bbd2440c1c40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#ab275cec979cdef3a044bbd2440c1c40b">More...</a><br /></td></tr>
<tr class="separator:ab275cec979cdef3a044bbd2440c1c40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7577366018a1358ea8b1046ccceb725d"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a7577366018a1358ea8b1046ccceb725d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a7577366018a1358ea8b1046ccceb725d">shared_ptr</a> (const std::shared_ptr&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7577366018a1358ea8b1046ccceb725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#a7577366018a1358ea8b1046ccceb725d">More...</a><br /></td></tr>
<tr class="separator:a7577366018a1358ea8b1046ccceb725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4ee826411aeb8b47eb713d642a2747"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#abc4ee826411aeb8b47eb713d642a2747">shared_ptr</a> (std::shared_ptr&lt; T &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:abc4ee826411aeb8b47eb713d642a2747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r.  <a href="#abc4ee826411aeb8b47eb713d642a2747">More...</a><br /></td></tr>
<tr class="separator:abc4ee826411aeb8b47eb713d642a2747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9585917485c16c64bbeca779d013341"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ad9585917485c16c64bbeca779d013341"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad9585917485c16c64bbeca779d013341">shared_ptr</a> (std::shared_ptr&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9585917485c16c64bbeca779d013341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r.  <a href="#ad9585917485c16c64bbeca779d013341">More...</a><br /></td></tr>
<tr class="separator:ad9585917485c16c64bbeca779d013341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dade5a1766da648dfa9d038b399337"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ad2dade5a1766da648dfa9d038b399337"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad2dade5a1766da648dfa9d038b399337">shared_ptr</a> (const std::weak_ptr&lt; Y &gt; &amp;r)</td></tr>
<tr class="memdesc:ad2dade5a1766da648dfa9d038b399337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#ad2dade5a1766da648dfa9d038b399337">More...</a><br /></td></tr>
<tr class="separator:ad2dade5a1766da648dfa9d038b399337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f189b92598518e7af5573a38ea58bf4"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:a6f189b92598518e7af5573a38ea58bf4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a6f189b92598518e7af5573a38ea58bf4">shared_ptr</a> (std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;r)</td></tr>
<tr class="memdesc:a6f189b92598518e7af5573a38ea58bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which manages the object currently managed by r.  <a href="#a6f189b92598518e7af5573a38ea58bf4">More...</a><br /></td></tr>
<tr class="separator:a6f189b92598518e7af5573a38ea58bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cc5667da5f447a673b830182bd8694"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad4cc5667da5f447a673b830182bd8694">~shared_ptr</a> ()=default</td></tr>
<tr class="memdesc:ad4cc5667da5f447a673b830182bd8694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor If *this owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, the object is destroyed through the owned deleter. After the destruction, the smart pointers that shared ownership with *this, if any, will report a <a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008" title="Returns the number of different shared_ptr instances (this included) managing the current object...">use_count()</a> that is one less than its previous value.  <a href="#ad4cc5667da5f447a673b830182bd8694">More...</a><br /></td></tr>
<tr class="separator:ad4cc5667da5f447a673b830182bd8694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1807b975ea13fa9e7968e811aa958d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae1807b975ea13fa9e7968e811aa958d0">operator=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1807b975ea13fa9e7968e811aa958d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae1807b975ea13fa9e7968e811aa958d0">More...</a><br /></td></tr>
<tr class="separator:ae1807b975ea13fa9e7968e811aa958d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3027ae00ef224d43f22919cc87477f3"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ab3027ae00ef224d43f22919cc87477f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab3027ae00ef224d43f22919cc87477f3">operator=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab3027ae00ef224d43f22919cc87477f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ab3027ae00ef224d43f22919cc87477f3">More...</a><br /></td></tr>
<tr class="separator:ab3027ae00ef224d43f22919cc87477f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#acfb208ac75f336aa0a75d5ae5840c7a9">operator=</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#acfb208ac75f336aa0a75d5ae5840c7a9">More...</a><br /></td></tr>
<tr class="separator:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548afd78e890d2f137470ccfcab3dc1"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a1548afd78e890d2f137470ccfcab3dc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a1548afd78e890d2f137470ccfcab3dc1">operator=</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1548afd78e890d2f137470ccfcab3dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1548afd78e890d2f137470ccfcab3dc1">More...</a><br /></td></tr>
<tr class="separator:a1548afd78e890d2f137470ccfcab3dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b18ade0444382d2216a774d91dec03"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:ae8b18ade0444382d2216a774d91dec03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae8b18ade0444382d2216a774d91dec03">operator=</a> (std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;r)</td></tr>
<tr class="memdesc:ae8b18ade0444382d2216a774d91dec03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae8b18ade0444382d2216a774d91dec03">More...</a><br /></td></tr>
<tr class="separator:ae8b18ade0444382d2216a774d91dec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e2abb060d2a13f3567f9ce045c153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">swap</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad9e2abb060d2a13f3567f9ce045c153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of *this and r.  <a href="#aad9e2abb060d2a13f3567f9ce045c153">More...</a><br /></td></tr>
<tr class="separator:aad9e2abb060d2a13f3567f9ce045c153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173bf63cf0e01263baf3afae88535f40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a173bf63cf0e01263baf3afae88535f40">reset</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a173bf63cf0e01263baf3afae88535f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership of the managed object, if any.  <a href="#a173bf63cf0e01263baf3afae88535f40">More...</a><br /></td></tr>
<tr class="separator:a173bf63cf0e01263baf3afae88535f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a0bb0f1efe277175d5c1a957cdc4cda5e">reset</a> (Y *ptr)</td></tr>
<tr class="memdesc:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a0bb0f1efe277175d5c1a957cdc4cda5e">More...</a><br /></td></tr>
<tr class="separator:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21842be121cec2d05a5b39965918d95f"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:a21842be121cec2d05a5b39965918d95f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a21842be121cec2d05a5b39965918d95f">reset</a> (Y *ptr, Deleter d)</td></tr>
<tr class="memdesc:a21842be121cec2d05a5b39965918d95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a21842be121cec2d05a5b39965918d95f">More...</a><br /></td></tr>
<tr class="separator:a21842be121cec2d05a5b39965918d95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968342ee500acff2d83691e8828fa0da"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter , class Alloc &gt; </td></tr>
<tr class="memitem:a968342ee500acff2d83691e8828fa0da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a968342ee500acff2d83691e8828fa0da">reset</a> (Y *ptr, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:a968342ee500acff2d83691e8828fa0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a968342ee500acff2d83691e8828fa0da">More...</a><br /></td></tr>
<tr class="separator:a968342ee500acff2d83691e8828fa0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec384df8969069cdff85c8b756b80df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8">get</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec384df8969069cdff85c8b756b80df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored pointer.  <a href="#aec384df8969069cdff85c8b756b80df8">More...</a><br /></td></tr>
<tr class="separator:aec384df8969069cdff85c8b756b80df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae7fe1242c57e9bc97175c33e332c9f3e">get_std_shared_ptr</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying std::shared_pointer.  <a href="#ae7fe1242c57e9bc97175c33e332c9f3e">More...</a><br /></td></tr>
<tr class="separator:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a3cf9520d9664eb6041ce5bdfcff601c0">get_std_shared_ptr</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying std::shared_pointer.  <a href="#a3cf9520d9664eb6041ce5bdfcff601c0">More...</a><br /></td></tr>
<tr class="separator:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808fe4734c4f5b50aeb619b955c541cb"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a808fe4734c4f5b50aeb619b955c541cb">operator*</a> () const</td></tr>
<tr class="memdesc:a808fe4734c4f5b50aeb619b955c541cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer.  <a href="#a808fe4734c4f5b50aeb619b955c541cb">More...</a><br /></td></tr>
<tr class="separator:a808fe4734c4f5b50aeb619b955c541cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7854da15a69cb3219e01d07341434ef"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa7854da15a69cb3219e01d07341434ef">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aa7854da15a69cb3219e01d07341434ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer.  <a href="#aa7854da15a69cb3219e01d07341434ef">More...</a><br /></td></tr>
<tr class="separator:aa7854da15a69cb3219e01d07341434ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b94995424c621626f96be0c5a78008"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008">use_count</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a93b94995424c621626f96be0c5a78008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of different <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> instances (this included) managing the current object.  <a href="#a93b94995424c621626f96be0c5a78008">More...</a><br /></td></tr>
<tr class="separator:a93b94995424c621626f96be0c5a78008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc074fa05cbecb5a9f6118659479ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a3ebc074fa05cbecb5a9f6118659479ef">operator bool</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ebc074fa05cbecb5a9f6118659479ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> != nullptr.  <a href="#a3ebc074fa05cbecb5a9f6118659479ef">More...</a><br /></td></tr>
<tr class="separator:a3ebc074fa05cbecb5a9f6118659479ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82f668471868b770acdbbb7d7d90d8"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:aeb82f668471868b770acdbbb7d7d90d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aeb82f668471868b770acdbbb7d7d90d8">owner_before</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb82f668471868b770acdbbb7d7d90d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#aeb82f668471868b770acdbbb7d7d90d8">More...</a><br /></td></tr>
<tr class="separator:aeb82f668471868b770acdbbb7d7d90d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812325d06d93650b08f1ae403b11cdf5"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a812325d06d93650b08f1ae403b11cdf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a812325d06d93650b08f1ae403b11cdf5">owner_before</a> (const std::shared_ptr&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a812325d06d93650b08f1ae403b11cdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#a812325d06d93650b08f1ae403b11cdf5">More...</a><br /></td></tr>
<tr class="separator:a812325d06d93650b08f1ae403b11cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#adea9dbdbe9f9db8d04a75b4447ef430d">owner_before</a> (const std::weak_ptr&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#adea9dbdbe9f9db8d04a75b4447ef430d">More...</a><br /></td></tr>
<tr class="separator:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab2104fa6e839672da3c30400e8325e52"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ab2104fa6e839672da3c30400e8325e52"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab2104fa6e839672da3c30400e8325e52">shared_ptr</a></td></tr>
<tr class="separator:ab2104fa6e839672da3c30400e8325e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class throwing::shared_ptr&lt; T &gt;</h3>

<p>Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. </p>
<p><a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a> is a smart pointer that retains shared ownership of an object through a pointer. Several <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:</p><ul>
<li>the last remaining <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning the object is destroyed;</li>
<li>the last remaining <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning the object is assigned another pointer via operator= or <a class="el" href="classthrowing_1_1shared__ptr.html#a173bf63cf0e01263baf3afae88535f40" title="Releases the ownership of the managed object, if any. ">reset()</a>.</li>
</ul>
<p>The object is destroyed using delete-expression or a custom deleter that is supplied to <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> during construction.</p>
<p>A <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> can share ownership of an object while storing a pointer to another object. This feature can be used to point to member objects while owning the object they belong to. The stored pointer is the one accessed by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a>, the dereference and the comparison operators. The managed pointer is the one passed to the deleter when use count reaches zero.</p>
<p>A <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> may also own no objects, in which case it is called empty (an empty <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> may have a non-null stored pointer if the aliasing constructor was used to create it).</p>
<p>All specializations of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> meet the requirements of CopyConstructible, CopyAssignable, and LessThanComparable and are contextually convertible to bool.</p>
<p>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> without synchronization and any of those accesses uses a non-const member function of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> then a data race will occur; the <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> overloads of atomic functions can be used to prevent the data race.</p>
<p>The underlying std::shared_ptr is available via <a class="el" href="classthrowing_1_1shared__ptr.html#a3cf9520d9664eb6041ce5bdfcff601c0" title="Returns the underlying std::shared_pointer. ">get_std_shared_ptr()</a> </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00063">63</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ae00f4f07e98dbb7c5d3cee41c95ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae00f4f07e98dbb7c5d3cee41c95ca2">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;T&gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type pointed to. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00066">66</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa56578e272392918e0f6100fa68b0460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56578e272392918e0f6100fa68b0460">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>. </p>

</div>
</div>
<a id="a280413aaeec3ea76a49386400b784d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280413aaeec3ea76a49386400b784d22">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00079">79</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;: p(ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a7f771212443dfc2a6ec4e9d81105597b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f771212443dfc2a6ec4e9d81105597b">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00084">84</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;: p(ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="aa7cf8abd4690a05a51fad4422a7e2c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cf8abd4690a05a51fad4422a7e2c10">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00098">98</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;: p(ptr, d) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a23e456cc2d34c98692a85af139a6b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e456cc2d34c98692a85af139a6b6ab">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00112">112</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;: p(ptr, d) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ab2ea12ca9c62996c9bea2cfae44cee0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ea12ca9c62996c9bea2cfae44cee0a">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions.</p>
<p>Uses a copy of alloc for allocation of data for internal use.</p>
<p>Alloc must be a Allocator. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00130">130</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;: p(ptr, d, alloc) {}</div></div><!-- fragment -->
</div>
</div>
<a id="afdfb374e4475de66502cb266a09a4722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfb374e4475de66502cb266a09a4722">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The aliasing constructor. </p>
<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership information with r, but holds an unrelated and unmanaged pointer ptr. Even if this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> is the last of the group to go out of scope, it will call the destructor for the object originally managed by r.</p>
<p>However, calling <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> on this will always return a copy of ptr.</p>
<p>It is the responsibility of the programmer to make sure that this ptr remains valid as long as this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias (e.g., downcast) of r.get() </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00147">147</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            : p(r.p, ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="af209003d1d20bb8b0b732d92011812b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af209003d1d20bb8b0b732d92011812b0">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00155">155</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;: p(r.p) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a6002b7b79c7e6a7eccc7bc10c350ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6002b7b79c7e6a7eccc7bc10c350ba99">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00163">163</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;: p(r.p) {}</div></div><!-- fragment -->
</div>
</div>
<a id="adc732d6edcc4ac98d17ab2d95ac02fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc732d6edcc4ac98d17ab2d95ac02fa5">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00170">170</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;: p(std::move(r.p)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a38e386182530e963bb27d04aea3cf3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e386182530e963bb27d04aea3cf3f3">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00178">178</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;: p(std::move(r.p)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ab275cec979cdef3a044bbd2440c1c40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab275cec979cdef3a044bbd2440c1c40b">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00185">185</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a7577366018a1358ea8b1046ccceb725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7577366018a1358ea8b1046ccceb725d">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00193">193</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="abc4ee826411aeb8b47eb713d642a2747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4ee826411aeb8b47eb713d642a2747">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00200">200</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad9585917485c16c64bbeca779d013341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9585917485c16c64bbeca779d013341">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00208">208</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad2dade5a1766da648dfa9d038b399337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dade5a1766da648dfa9d038b399337">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::weak_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>Y* must be implicitly convertible to T*. (until C++17)</p>
<p>This overload only participates in overload resolution if Y* is compatible with T*. (since C++17)</p>
<p>Note that r.lock() may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while std::weak_ptr&lt;T&gt;::lock() constructs an empty std::shared_ptr in that case. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00223">223</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a6f189b92598518e7af5573a38ea58bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f189b92598518e7af5573a38ea58bf4">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> which manages the object currently managed by r. </p>
<p>The deleter associated with r is stored for future deletion of the managed object.</p>
<p>r manages no object after the call.</p>
<p>This overload doesn't participate in overload resolution if std::unique_ptr&lt;Y, Deleter&gt;::pointer is not compatible with T*. If r.get() is a null pointer, this overload is equivalent to the default constructor (1). (since C++17)</p>
<p>If Deleter is a reference type, equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>(r.release(), std::ref(<a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a" title="Access to the p&#39;s deleter. ">r.get_deleter()</a>). Otherwise, equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>(r.release(), <a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a" title="Access to the p&#39;s deleter. ">r.get_deleter()</a>) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00243">243</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad4cc5667da5f447a673b830182bd8694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cc5667da5f447a673b830182bd8694">&#9670;&nbsp;</a></span>~shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::~<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor If *this owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, the object is destroyed through the owned deleter. After the destruction, the smart pointers that shared ownership with *this, if any, will report a <a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008" title="Returns the number of different shared_ptr instances (this included) managing the current object...">use_count()</a> that is one less than its previous value. </p>
<p>Notes:</p>
<p>Unlike <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>, the throwing of std::shared_ptr is invoked even if the managed pointer is null. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aec384df8969069cdff85c8b756b80df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec384df8969069cdff85c8b756b80df8">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a>* <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stored pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00407">407</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;{ <span class="keywordflow">return</span> p.get(); }</div></div><!-- fragment -->
</div>
</div>
<a id="ae7fe1242c57e9bc97175c33e332c9f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe1242c57e9bc97175c33e332c9f3e">&#9670;&nbsp;</a></span>get_std_shared_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;T&gt;&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get_std_shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying std::shared_pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00411">411</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                                                                    {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        <span class="keywordflow">return</span> p;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a3cf9520d9664eb6041ce5bdfcff601c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9520d9664eb6041ce5bdfcff601c0">&#9670;&nbsp;</a></span>get_std_shared_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt;&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get_std_shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying std::shared_pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00417">417</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;{ <span class="keywordflow">return</span> p; }</div></div><!-- fragment -->
</div>
</div>
<a id="a3ebc074fa05cbecb5a9f6118659479ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc074fa05cbecb5a9f6118659479ef">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> != nullptr. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00475">475</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;{ <span class="keywordflow">return</span> p.operator bool(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a808fe4734c4f5b50aeb619b955c541cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808fe4734c4f5b50aeb619b955c541cb">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">null_ptr_exception&lt;T&gt;</td><td>if the pointer is null </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00423">423</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                         {</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> ptr = <span class="keyword">get</span>();</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == ptr)</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            <span class="keywordflow">throw</span> null_ptr_exception&lt;T&gt;();</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="keywordflow">return</span> *ptr;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aa7854da15a69cb3219e01d07341434ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7854da15a69cb3219e01d07341434ef">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">null_ptr_exception&lt;T&gt;</td><td>if the pointer is null </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00434">434</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                          {</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> ptr = <span class="keyword">get</span>();</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == ptr)</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="keywordflow">throw</span> null_ptr_exception&lt;T&gt;();</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <span class="keywordflow">return</span> ptr;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ae1807b975ea13fa9e7968e811aa958d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1807b975ea13fa9e7968e811aa958d0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Shares ownership of the object managed by r. If r manages no object, *this manages no object too. Equivalent to shared_ptr&lt;T&gt;(r).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00270">270</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                                                            {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        p = r.p;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ab3027ae00ef224d43f22919cc87477f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3027ae00ef224d43f22919cc87477f3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Shares ownership of the object managed by r. If r manages no object, *this manages no object too. Equivalent to shared_ptr&lt;T&gt;(r).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00287">287</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                                                               {</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        p = r.p;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="acfb208ac75f336aa0a75d5ae5840c7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb208ac75f336aa0a75d5ae5840c7a9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Move-assigns a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. After the assignment, *this contains a copy of the previous state of r, r is empty. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00303">303</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                                       {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        p = std::move(r.p);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a1548afd78e890d2f137470ccfcab3dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548afd78e890d2f137470ccfcab3dc1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Move-assigns a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> from r. After the assignment, *this contains a copy of the previous state of r, r is empty. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00319">319</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                                                                             {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        p = std::move(r.p);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ae8b18ade0444382d2216a774d91dec03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b18ade0444382d2216a774d91dec03">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Transfers the ownership of the object managed by r to *this. The deleter associated to r is stored for future deletion of the managed object. r manages no object after the call. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00337">337</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                                         {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        p = std::move(r);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aeb82f668471868b770acdbbb7d7d90d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82f668471868b770acdbbb7d7d90d8">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00489">489</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                                                                     {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other.p);</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a812325d06d93650b08f1ae403b11cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812325d06d93650b08f1ae403b11cdf5">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00505">505</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                                                                        {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="adea9dbdbe9f9db8d04a75b4447ef430d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea9dbdbe9f9db8d04a75b4447ef430d">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const std::weak_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00521">521</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                                                                      {</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other);</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a173bf63cf0e01263baf3afae88535f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173bf63cf0e01263baf3afae88535f40">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the ownership of the managed object, if any. </p>
<p>If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> owning it, the object is destroyed through the owned deleter. If the object pointed to by ptr is already owned, the function results in undefined behavior.</p>
<p>After the call, *this manages no object. Equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html#aa56578e272392918e0f6100fa68b0460" title="Constructs a shared_ptr with no managed object, i.e. empty shared_ptr. ">shared_ptr()</a>.swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00356">356</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;{ p.reset(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a0bb0f1efe277175d5c1a957cdc4cda5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb0f1efe277175d5c1a957cdc4cda5e">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the delete expression as the deleter. A valid delete expression must be available, i.e. delete ptr must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00368">368</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{ p.reset(ptr); }</div></div><!-- fragment -->
</div>
</div>
<a id="a21842be121cec2d05a5b39965918d95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21842be121cec2d05a5b39965918d95f">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the specified deleter d as the deleter. Deleter must be callable for the type T, i.e. d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be CopyConstructible, and its copy constructor and destructor must not throw exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr, d).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00381">381</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                                                                    {</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        p.reset(ptr, d);</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a968342ee500acff2d83691e8828fa0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968342ee500acff2d83691e8828fa0da">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the specified deleter d as the deleter. Deleter must be callable for the type T, i.e. d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be CopyConstructible, and its copy constructor and destructor must not throw exceptions.</p>
<p>Additionally uses a copy of alloc for allocation of data for internal use. Alloc must be a Allocator. The copy constructor and destructor must not throw exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr, d, alloc).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00401">401</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                               {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        p.reset(ptr, d, alloc);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aad9e2abb060d2a13f3567f9ce045c153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9e2abb060d2a13f3567f9ce045c153">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of *this and r. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00344">344</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;{ p.swap(r.p); }</div></div><!-- fragment -->
</div>
</div>
<a id="a93b94995424c621626f96be0c5a78008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b94995424c621626f96be0c5a78008">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of different <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> instances (this included) managing the current object. </p>
<p>If there is no managed object, ​0​ is returned.</p>
<p>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a memory_order_relaxed load) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00470">470</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;{ <span class="keywordflow">return</span> p.use_count(); }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab2104fa6e839672da3c30400e8325e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2104fa6e839672da3c30400e8325e52">&#9670;&nbsp;</a></span>shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00069">69</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/throwing/<a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
