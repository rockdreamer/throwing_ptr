<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>throwing_ptr: throwing::shared_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">throwing_ptr
   </div>
   <div id="projectbrief">Smart pointers that throw on dereference if null</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacethrowing.html">throwing</a></li><li class="navelem"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classthrowing_1_1shared__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">throwing::shared_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ae00f4f07e98dbb7c5d3cee41c95ca2"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a></td></tr>
<tr class="separator:a5ae00f4f07e98dbb7c5d3cee41c95ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa56578e272392918e0f6100fa68b0460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa56578e272392918e0f6100fa68b0460">shared_ptr</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a>=default</td></tr>
<tr class="memdesc:aa56578e272392918e0f6100fa68b0460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>.  <a href="#aa56578e272392918e0f6100fa68b0460">More...</a><br /></td></tr>
<tr class="separator:aa56578e272392918e0f6100fa68b0460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280413aaeec3ea76a49386400b784d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a280413aaeec3ea76a49386400b784d22">shared_ptr</a> (std::nullptr_t ptr) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a280413aaeec3ea76a49386400b784d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>.  <a href="#a280413aaeec3ea76a49386400b784d22">More...</a><br /></td></tr>
<tr class="separator:a280413aaeec3ea76a49386400b784d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f771212443dfc2a6ec4e9d81105597b"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a7f771212443dfc2a6ec4e9d81105597b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a7f771212443dfc2a6ec4e9d81105597b">shared_ptr</a> (Y *ptr)</td></tr>
<tr class="memdesc:a7f771212443dfc2a6ec4e9d81105597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#a7f771212443dfc2a6ec4e9d81105597b">More...</a><br /></td></tr>
<tr class="separator:a7f771212443dfc2a6ec4e9d81105597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa7cf8abd4690a05a51fad4422a7e2c10">shared_ptr</a> (Y *ptr, Deleter d)</td></tr>
<tr class="memdesc:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#aa7cf8abd4690a05a51fad4422a7e2c10">More...</a><br /></td></tr>
<tr class="separator:aa7cf8abd4690a05a51fad4422a7e2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e456cc2d34c98692a85af139a6b6ab"><td class="memTemplParams" colspan="2">template&lt;class Deleter &gt; </td></tr>
<tr class="memitem:a23e456cc2d34c98692a85af139a6b6ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a23e456cc2d34c98692a85af139a6b6ab">shared_ptr</a> (std::nullptr_t ptr, Deleter d)</td></tr>
<tr class="memdesc:a23e456cc2d34c98692a85af139a6b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#a23e456cc2d34c98692a85af139a6b6ab">More...</a><br /></td></tr>
<tr class="separator:a23e456cc2d34c98692a85af139a6b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter , class Alloc &gt; </td></tr>
<tr class="memitem:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab2ea12ca9c62996c9bea2cfae44cee0a">shared_ptr</a> (Y *ptr, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object.  <a href="#ab2ea12ca9c62996c9bea2cfae44cee0a">More...</a><br /></td></tr>
<tr class="separator:ab2ea12ca9c62996c9bea2cfae44cee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfb374e4475de66502cb266a09a4722"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:afdfb374e4475de66502cb266a09a4722"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#afdfb374e4475de66502cb266a09a4722">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r, <a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *ptr) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:afdfb374e4475de66502cb266a09a4722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aliasing constructor.  <a href="#afdfb374e4475de66502cb266a09a4722">More...</a><br /></td></tr>
<tr class="separator:afdfb374e4475de66502cb266a09a4722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af209003d1d20bb8b0b732d92011812b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#af209003d1d20bb8b0b732d92011812b0">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:af209003d1d20bb8b0b732d92011812b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#af209003d1d20bb8b0b732d92011812b0">More...</a><br /></td></tr>
<tr class="separator:af209003d1d20bb8b0b732d92011812b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a6002b7b79c7e6a7eccc7bc10c350ba99">shared_ptr</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#a6002b7b79c7e6a7eccc7bc10c350ba99">More...</a><br /></td></tr>
<tr class="separator:a6002b7b79c7e6a7eccc7bc10c350ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#adc732d6edcc4ac98d17ab2d95ac02fa5">shared_ptr</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r.  <a href="#adc732d6edcc4ac98d17ab2d95ac02fa5">More...</a><br /></td></tr>
<tr class="separator:adc732d6edcc4ac98d17ab2d95ac02fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e386182530e963bb27d04aea3cf3f3"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a38e386182530e963bb27d04aea3cf3f3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a38e386182530e963bb27d04aea3cf3f3">shared_ptr</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38e386182530e963bb27d04aea3cf3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r.  <a href="#a38e386182530e963bb27d04aea3cf3f3">More...</a><br /></td></tr>
<tr class="separator:a38e386182530e963bb27d04aea3cf3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab275cec979cdef3a044bbd2440c1c40b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab275cec979cdef3a044bbd2440c1c40b">shared_ptr</a> (const std::shared_ptr&lt; T &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab275cec979cdef3a044bbd2440c1c40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#ab275cec979cdef3a044bbd2440c1c40b">More...</a><br /></td></tr>
<tr class="separator:ab275cec979cdef3a044bbd2440c1c40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7577366018a1358ea8b1046ccceb725d"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a7577366018a1358ea8b1046ccceb725d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a7577366018a1358ea8b1046ccceb725d">shared_ptr</a> (const std::shared_ptr&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7577366018a1358ea8b1046ccceb725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#a7577366018a1358ea8b1046ccceb725d">More...</a><br /></td></tr>
<tr class="separator:a7577366018a1358ea8b1046ccceb725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4ee826411aeb8b47eb713d642a2747"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#abc4ee826411aeb8b47eb713d642a2747">shared_ptr</a> (std::shared_ptr&lt; T &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:abc4ee826411aeb8b47eb713d642a2747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r.  <a href="#abc4ee826411aeb8b47eb713d642a2747">More...</a><br /></td></tr>
<tr class="separator:abc4ee826411aeb8b47eb713d642a2747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9585917485c16c64bbeca779d013341"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ad9585917485c16c64bbeca779d013341"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad9585917485c16c64bbeca779d013341">shared_ptr</a> (std::shared_ptr&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9585917485c16c64bbeca779d013341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r.  <a href="#ad9585917485c16c64bbeca779d013341">More...</a><br /></td></tr>
<tr class="separator:ad9585917485c16c64bbeca779d013341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dade5a1766da648dfa9d038b399337"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ad2dade5a1766da648dfa9d038b399337"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad2dade5a1766da648dfa9d038b399337">shared_ptr</a> (const std::weak_ptr&lt; Y &gt; &amp;r)</td></tr>
<tr class="memdesc:ad2dade5a1766da648dfa9d038b399337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r.  <a href="#ad2dade5a1766da648dfa9d038b399337">More...</a><br /></td></tr>
<tr class="separator:ad2dade5a1766da648dfa9d038b399337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f189b92598518e7af5573a38ea58bf4"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:a6f189b92598518e7af5573a38ea58bf4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a6f189b92598518e7af5573a38ea58bf4">shared_ptr</a> (std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;r)</td></tr>
<tr class="memdesc:a6f189b92598518e7af5573a38ea58bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which manages the object currently managed by r.  <a href="#a6f189b92598518e7af5573a38ea58bf4">More...</a><br /></td></tr>
<tr class="separator:a6f189b92598518e7af5573a38ea58bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cc5667da5f447a673b830182bd8694"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ad4cc5667da5f447a673b830182bd8694">~shared_ptr</a> ()=default</td></tr>
<tr class="memdesc:ad4cc5667da5f447a673b830182bd8694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor If *this owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, the object is destroyed through the owned deleter. After the destruction, the smart pointers that shared ownership with *this, if any, will report a <a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008" title="Returns the number of different shared_ptr instances (this included) managing the current object...">use_count()</a> that is one less than its previous value.  <a href="#ad4cc5667da5f447a673b830182bd8694">More...</a><br /></td></tr>
<tr class="separator:ad4cc5667da5f447a673b830182bd8694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1807b975ea13fa9e7968e811aa958d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae1807b975ea13fa9e7968e811aa958d0">operator=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1807b975ea13fa9e7968e811aa958d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae1807b975ea13fa9e7968e811aa958d0">More...</a><br /></td></tr>
<tr class="separator:ae1807b975ea13fa9e7968e811aa958d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3027ae00ef224d43f22919cc87477f3"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ab3027ae00ef224d43f22919cc87477f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab3027ae00ef224d43f22919cc87477f3">operator=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab3027ae00ef224d43f22919cc87477f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ab3027ae00ef224d43f22919cc87477f3">More...</a><br /></td></tr>
<tr class="separator:ab3027ae00ef224d43f22919cc87477f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#acfb208ac75f336aa0a75d5ae5840c7a9">operator=</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#acfb208ac75f336aa0a75d5ae5840c7a9">More...</a><br /></td></tr>
<tr class="separator:acfb208ac75f336aa0a75d5ae5840c7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548afd78e890d2f137470ccfcab3dc1"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a1548afd78e890d2f137470ccfcab3dc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a1548afd78e890d2f137470ccfcab3dc1">operator=</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1548afd78e890d2f137470ccfcab3dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1548afd78e890d2f137470ccfcab3dc1">More...</a><br /></td></tr>
<tr class="separator:a1548afd78e890d2f137470ccfcab3dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b18ade0444382d2216a774d91dec03"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:ae8b18ade0444382d2216a774d91dec03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae8b18ade0444382d2216a774d91dec03">operator=</a> (std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;r)</td></tr>
<tr class="memdesc:ae8b18ade0444382d2216a774d91dec03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ae8b18ade0444382d2216a774d91dec03">More...</a><br /></td></tr>
<tr class="separator:ae8b18ade0444382d2216a774d91dec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e2abb060d2a13f3567f9ce045c153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">swap</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aad9e2abb060d2a13f3567f9ce045c153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of *this and r.  <a href="#aad9e2abb060d2a13f3567f9ce045c153">More...</a><br /></td></tr>
<tr class="separator:aad9e2abb060d2a13f3567f9ce045c153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173bf63cf0e01263baf3afae88535f40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a173bf63cf0e01263baf3afae88535f40">reset</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a173bf63cf0e01263baf3afae88535f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership of the managed object, if any.  <a href="#a173bf63cf0e01263baf3afae88535f40">More...</a><br /></td></tr>
<tr class="separator:a173bf63cf0e01263baf3afae88535f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a0bb0f1efe277175d5c1a957cdc4cda5e">reset</a> (Y *ptr)</td></tr>
<tr class="memdesc:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a0bb0f1efe277175d5c1a957cdc4cda5e">More...</a><br /></td></tr>
<tr class="separator:a0bb0f1efe277175d5c1a957cdc4cda5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21842be121cec2d05a5b39965918d95f"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter &gt; </td></tr>
<tr class="memitem:a21842be121cec2d05a5b39965918d95f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a21842be121cec2d05a5b39965918d95f">reset</a> (Y *ptr, Deleter d)</td></tr>
<tr class="memdesc:a21842be121cec2d05a5b39965918d95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a21842be121cec2d05a5b39965918d95f">More...</a><br /></td></tr>
<tr class="separator:a21842be121cec2d05a5b39965918d95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968342ee500acff2d83691e8828fa0da"><td class="memTemplParams" colspan="2">template&lt;class Y , class Deleter , class Alloc &gt; </td></tr>
<tr class="memitem:a968342ee500acff2d83691e8828fa0da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a968342ee500acff2d83691e8828fa0da">reset</a> (Y *ptr, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:a968342ee500acff2d83691e8828fa0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr.  <a href="#a968342ee500acff2d83691e8828fa0da">More...</a><br /></td></tr>
<tr class="separator:a968342ee500acff2d83691e8828fa0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec384df8969069cdff85c8b756b80df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8">get</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec384df8969069cdff85c8b756b80df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored pointer.  <a href="#aec384df8969069cdff85c8b756b80df8">More...</a><br /></td></tr>
<tr class="separator:aec384df8969069cdff85c8b756b80df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ae7fe1242c57e9bc97175c33e332c9f3e">get_std_shared_ptr</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying std::shared_pointer.  <a href="#ae7fe1242c57e9bc97175c33e332c9f3e">More...</a><br /></td></tr>
<tr class="separator:ae7fe1242c57e9bc97175c33e332c9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a3cf9520d9664eb6041ce5bdfcff601c0">get_std_shared_ptr</a> () <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying std::shared_pointer.  <a href="#a3cf9520d9664eb6041ce5bdfcff601c0">More...</a><br /></td></tr>
<tr class="separator:a3cf9520d9664eb6041ce5bdfcff601c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808fe4734c4f5b50aeb619b955c541cb"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a808fe4734c4f5b50aeb619b955c541cb">operator*</a> () const</td></tr>
<tr class="memdesc:a808fe4734c4f5b50aeb619b955c541cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer.  <a href="#a808fe4734c4f5b50aeb619b955c541cb">More...</a><br /></td></tr>
<tr class="separator:a808fe4734c4f5b50aeb619b955c541cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7854da15a69cb3219e01d07341434ef"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aa7854da15a69cb3219e01d07341434ef">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aa7854da15a69cb3219e01d07341434ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer.  <a href="#aa7854da15a69cb3219e01d07341434ef">More...</a><br /></td></tr>
<tr class="separator:aa7854da15a69cb3219e01d07341434ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b94995424c621626f96be0c5a78008"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008">use_count</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a93b94995424c621626f96be0c5a78008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of different <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> instances (this included) managing the current object.  <a href="#a93b94995424c621626f96be0c5a78008">More...</a><br /></td></tr>
<tr class="separator:a93b94995424c621626f96be0c5a78008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc074fa05cbecb5a9f6118659479ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a3ebc074fa05cbecb5a9f6118659479ef">operator bool</a> () const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ebc074fa05cbecb5a9f6118659479ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> != nullptr.  <a href="#a3ebc074fa05cbecb5a9f6118659479ef">More...</a><br /></td></tr>
<tr class="separator:a3ebc074fa05cbecb5a9f6118659479ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82f668471868b770acdbbb7d7d90d8"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:aeb82f668471868b770acdbbb7d7d90d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#aeb82f668471868b770acdbbb7d7d90d8">owner_before</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb82f668471868b770acdbbb7d7d90d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#aeb82f668471868b770acdbbb7d7d90d8">More...</a><br /></td></tr>
<tr class="separator:aeb82f668471868b770acdbbb7d7d90d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812325d06d93650b08f1ae403b11cdf5"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a812325d06d93650b08f1ae403b11cdf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#a812325d06d93650b08f1ae403b11cdf5">owner_before</a> (const std::shared_ptr&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a812325d06d93650b08f1ae403b11cdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#a812325d06d93650b08f1ae403b11cdf5">More...</a><br /></td></tr>
<tr class="separator:a812325d06d93650b08f1ae403b11cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#adea9dbdbe9f9db8d04a75b4447ef430d">owner_before</a> (const std::weak_ptr&lt; Y &gt; &amp;other) const <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#adea9dbdbe9f9db8d04a75b4447ef430d">More...</a><br /></td></tr>
<tr class="separator:adea9dbdbe9f9db8d04a75b4447ef430d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab2104fa6e839672da3c30400e8325e52"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ab2104fa6e839672da3c30400e8325e52"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html#ab2104fa6e839672da3c30400e8325e52">shared_ptr</a></td></tr>
<tr class="separator:ab2104fa6e839672da3c30400e8325e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class throwing::shared_ptr&lt; T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00016">16</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ae00f4f07e98dbb7c5d3cee41c95ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae00f4f07e98dbb7c5d3cee41c95ca2">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;T&gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00018">18</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa56578e272392918e0f6100fa68b0460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56578e272392918e0f6100fa68b0460">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>. </p>

</div>
</div>
<a id="a280413aaeec3ea76a49386400b784d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280413aaeec3ea76a49386400b784d22">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="compiler__checks_8hpp.html#a17d86c786b2138ba289c8d2ce7096892">TSP_CONSTEXPR</a> <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with no managed object, i.e. empty <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00031">31</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;: p(ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a7f771212443dfc2a6ec4e9d81105597b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f771212443dfc2a6ec4e9d81105597b">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00036">36</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;: p(ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="aa7cf8abd4690a05a51fad4422a7e2c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cf8abd4690a05a51fad4422a7e2c10">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00050">50</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;: p(ptr, d) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a23e456cc2d34c98692a85af139a6b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e456cc2d34c98692a85af139a6b6ab">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00064">64</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;: p(ptr, d) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ab2ea12ca9c62996c9bea2cfae44cee0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ea12ca9c62996c9bea2cfae44cee0a">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with ptr as the pointer to the managed object. </p>
<p>Uses the specified deleter d as the deleter.</p>
<p>The expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>The construction of d and of the stored deleter from d must not throw exceptions.</p>
<p>Uses a copy of alloc for allocation of data for internal use.</p>
<p>Alloc must be a Allocator. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00082">82</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;: p(ptr, d, alloc) {}</div></div><!-- fragment -->
</div>
</div>
<a id="afdfb374e4475de66502cb266a09a4722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfb374e4475de66502cb266a09a4722">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The aliasing constructor. </p>
<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership information with r, but holds an unrelated and unmanaged pointer ptr. Even if this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> is the last of the group to go out of scope, it will call the destructor for the object originally managed by r.</p>
<p>However, calling <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> on this will always return a copy of ptr.</p>
<p>It is the responsibility of the programmer to make sure that this ptr remains valid as long as this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> exists, such as in the typical use cases where ptr is a member of the object managed by r or is an alias (e.g., downcast) of r.get() </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00099">99</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            : p(r.p, ptr) {}</div></div><!-- fragment -->
</div>
</div>
<a id="af209003d1d20bb8b0b732d92011812b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af209003d1d20bb8b0b732d92011812b0">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00107">107</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;: p(r.p) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a6002b7b79c7e6a7eccc7bc10c350ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6002b7b79c7e6a7eccc7bc10c350ba99">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00115">115</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;: p(r.p) {}</div></div><!-- fragment -->
</div>
</div>
<a id="adc732d6edcc4ac98d17ab2d95ac02fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc732d6edcc4ac98d17ab2d95ac02fa5">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00122">122</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;: p(std::move(r.p)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a38e386182530e963bb27d04aea3cf3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e386182530e963bb27d04aea3cf3f3">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00130">130</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;: p(std::move(r.p)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ab275cec979cdef3a044bbd2440c1c40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab275cec979cdef3a044bbd2440c1c40b">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00137">137</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a7577366018a1358ea8b1046ccceb725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7577366018a1358ea8b1046ccceb725d">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>If r manages no object, *this manages no object too. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00145">145</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="abc4ee826411aeb8b47eb713d642a2747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4ee826411aeb8b47eb713d642a2747">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00152">152</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad9585917485c16c64bbeca779d013341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9585917485c16c64bbeca779d013341">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. </p>
<p>After the construction, *this contains a copy of the previous state of r, r is empty and its stored pointer is null. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00160">160</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad2dade5a1766da648dfa9d038b399337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dade5a1766da648dfa9d038b399337">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::weak_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which shares ownership of the object managed by r. </p>
<p>Y* must be implicitly convertible to T*. (until C++17)</p>
<p>This overload only participates in overload resolution if Y* is compatible with T*. (since C++17)</p>
<p>Note that r.lock() may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while std::weak_ptr&lt;T&gt;::lock() constructs an empty std::shared_ptr in that case. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00175">175</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;: p(r) {}</div></div><!-- fragment -->
</div>
</div>
<a id="a6f189b92598518e7af5573a38ea58bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f189b92598518e7af5573a38ea58bf4">&#9670;&nbsp;</a></span>shared_ptr() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> which manages the object currently managed by r. </p>
<p>The deleter associated with r is stored for future deletion of the managed object.</p>
<p>r manages no object after the call.</p>
<p>This overload doesn't participate in overload resolution if std::unique_ptr&lt;Y, Deleter&gt;::pointer is not compatible with T*. If r.get() is a null pointer, this overload is equivalent to the default constructor (1). (since C++17)</p>
<p>If Deleter is a reference type, equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>(r.release(), std::ref(<a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a" title="Access to the p&#39;s deleter. ">r.get_deleter()</a>). Otherwise, equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>(r.release(), <a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a" title="Access to the p&#39;s deleter. ">r.get_deleter()</a>) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00195">195</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;: p(std::move(r)) {}</div></div><!-- fragment -->
</div>
</div>
<a id="ad4cc5667da5f447a673b830182bd8694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cc5667da5f447a673b830182bd8694">&#9670;&nbsp;</a></span>~shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::~<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor If *this owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, the object is destroyed through the owned deleter. After the destruction, the smart pointers that shared ownership with *this, if any, will report a <a class="el" href="classthrowing_1_1shared__ptr.html#a93b94995424c621626f96be0c5a78008" title="Returns the number of different shared_ptr instances (this included) managing the current object...">use_count()</a> that is one less than its previous value. </p>
<p>Notes:</p>
<p>Unlike <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>, the throwing of std::shared_ptr is invoked even if the managed pointer is null. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aec384df8969069cdff85c8b756b80df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec384df8969069cdff85c8b756b80df8">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">element_type</a>* <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stored pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00359">359</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;{ <span class="keywordflow">return</span> p.get(); }</div></div><!-- fragment -->
</div>
</div>
<a id="ae7fe1242c57e9bc97175c33e332c9f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe1242c57e9bc97175c33e332c9f3e">&#9670;&nbsp;</a></span>get_std_shared_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;T&gt;&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get_std_shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying std::shared_pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00363">363</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                                                    {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">return</span> p;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a3cf9520d9664eb6041ce5bdfcff601c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9520d9664eb6041ce5bdfcff601c0">&#9670;&nbsp;</a></span>get_std_shared_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt;&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::get_std_shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying std::shared_pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00369">369</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{ <span class="keywordflow">return</span> p; }</div></div><!-- fragment -->
</div>
</div>
<a id="a3ebc074fa05cbecb5a9f6118659479ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc074fa05cbecb5a9f6118659479ef">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> != nullptr. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00427">427</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;{ <span class="keywordflow">return</span> p.operator bool(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a808fe4734c4f5b50aeb619b955c541cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808fe4734c4f5b50aeb619b955c541cb">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer. </p>
<p>Throws null_ptr_exception&lt;T&gt; if the pointer is null </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00375">375</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                         {</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> ptr = <span class="keyword">get</span>();</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == ptr)</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            <span class="keywordflow">throw</span> null_ptr_exception&lt;T&gt;();</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">return</span> *ptr;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aa7854da15a69cb3219e01d07341434ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7854da15a69cb3219e01d07341434ef">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer. </p>
<p>Throws null_ptr_exception&lt;T&gt; if the pointer is null </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00386">386</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                          {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> ptr = <span class="keyword">get</span>();</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == ptr)</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            <span class="keywordflow">throw</span> null_ptr_exception&lt;T&gt;();</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        <span class="keywordflow">return</span> ptr;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ae1807b975ea13fa9e7968e811aa958d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1807b975ea13fa9e7968e811aa958d0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Shares ownership of the object managed by r. If r manages no object, *this manages no object too. Equivalent to shared_ptr&lt;T&gt;(r).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00222">222</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                                            {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        p = r.p;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ab3027ae00ef224d43f22919cc87477f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3027ae00ef224d43f22919cc87477f3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Shares ownership of the object managed by r. If r manages no object, *this manages no object too. Equivalent to shared_ptr&lt;T&gt;(r).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00239">239</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                                                               {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        p = r.p;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="acfb208ac75f336aa0a75d5ae5840c7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb208ac75f336aa0a75d5ae5840c7a9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Move-assigns a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. After the assignment, *this contains a copy of the previous state of r, r is empty. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00255">255</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                                                       {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        p = std::move(r.p);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a1548afd78e890d2f137470ccfcab3dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548afd78e890d2f137470ccfcab3dc1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Move-assigns a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> from r. After the assignment, *this contains a copy of the previous state of r, r is empty. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00271">271</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                                                                             {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        p = std::move(r.p);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="ae8b18ade0444382d2216a774d91dec03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b18ade0444382d2216a774d91dec03">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&amp; <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y, Deleter &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Replaces the managed object with the one managed by r. If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, and r is not the same as *this, the object is destroyed through the owned deleter.</p>
<p>Transfers the ownership of the object managed by r to *this. The deleter associated to r is stored for future deletion of the managed object. r manages no object after the call. Equivalent to shared_ptr&lt;T&gt;(std::move(r)).swap(*this). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00289">289</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                                                         {</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        p = std::move(r);</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aeb82f668471868b770acdbbb7d7d90d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82f668471868b770acdbbb7d7d90d8">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00441">441</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                                                                     {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other.p);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a812325d06d93650b08f1ae403b11cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812325d06d93650b08f1ae403b11cdf5">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00457">457</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                                                                        {</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other);</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="adea9dbdbe9f9db8d04a75b4447ef430d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea9dbdbe9f9db8d04a75b4447ef430d">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const std::weak_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="classthrowing_1_1shared__ptr.html#aec384df8969069cdff85c8b756b80df8" title="Returns the stored pointer. ">get()</a> are different (e.g. because they point at different subobjects within the same object)</p>
<p>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00473">473</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                                                                      {</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordflow">return</span> p.owner_before(other);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a173bf63cf0e01263baf3afae88535f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173bf63cf0e01263baf3afae88535f40">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the ownership of the managed object, if any. </p>
<p>If *this already owns an object and it is the last <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> owning it, the object is destroyed through the owned deleter. If the object pointed to by ptr is already owned, the function results in undefined behavior.</p>
<p>After the call, *this manages no object. Equivalent to <a class="el" href="classthrowing_1_1shared__ptr.html#aa56578e272392918e0f6100fa68b0460" title="Constructs a shared_ptr with no managed object, i.e. empty shared_ptr. ">shared_ptr()</a>.swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00308">308</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;{ p.reset(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a0bb0f1efe277175d5c1a957cdc4cda5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb0f1efe277175d5c1a957cdc4cda5e">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the delete expression as the deleter. A valid delete expression must be available, i.e. delete ptr must be well formed, have well-defined behavior and not throw any exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00320">320</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;{ p.reset(ptr); }</div></div><!-- fragment -->
</div>
</div>
<a id="a21842be121cec2d05a5b39965918d95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21842be121cec2d05a5b39965918d95f">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the specified deleter d as the deleter. Deleter must be callable for the type T, i.e. d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be CopyConstructible, and its copy constructor and destructor must not throw exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr, d).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00333">333</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                                                                    {</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        p.reset(ptr, d);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a968342ee500acff2d83691e8828fa0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968342ee500acff2d83691e8828fa0da">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Y , class Deleter , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. </p>
<p>Y must be a complete type and implicitly convertible to T.</p>
<p>Uses the specified deleter d as the deleter. Deleter must be callable for the type T, i.e. d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be CopyConstructible, and its copy constructor and destructor must not throw exceptions.</p>
<p>Additionally uses a copy of alloc for allocation of data for internal use. Alloc must be a Allocator. The copy constructor and destructor must not throw exceptions.</p>
<p>Equivalent to shared_ptr&lt;T&gt;(ptr, d, alloc).swap(*this); </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00353">353</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                                               {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        p.reset(ptr, d, alloc);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aad9e2abb060d2a13f3567f9ce045c153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9e2abb060d2a13f3567f9ce045c153">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of *this and r. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00296">296</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;{ p.swap(r.p); }</div></div><!-- fragment -->
</div>
</div>
<a id="a93b94995424c621626f96be0c5a78008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b94995424c621626f96be0c5a78008">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of different <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> instances (this included) managing the current object. </p>
<p>If there is no managed object, ​0​ is returned.</p>
<p>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a memory_order_relaxed load) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00422">422</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;{ <span class="keywordflow">return</span> p.use_count(); }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab2104fa6e839672da3c30400e8325e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2104fa6e839672da3c30400e8325e52">&#9670;&nbsp;</a></span>shared_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00021">21</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/throwing/<a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
