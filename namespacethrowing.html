<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>throwing_ptr: throwing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">throwing_ptr
   </div>
   <div id="projectbrief">Smart pointers that throw on dereference if null</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">throwing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementations of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a>, <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> and related.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacethrowing_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrowing_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacethrowing_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers for make_unique type resolution, see n3656. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1base__null__ptr__exception.html">base_null_ptr_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class thrown upon dereferencing a null <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>.  <a href="classthrowing_1_1base__null__ptr__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1null__ptr__exception.html">null_ptr_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete class thrown upon dereferencing a null <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a>.  <a href="classthrowing_1_1null__ptr__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced.  <a href="classthrowing_1_1shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> that manages a single object  <a href="classthrowing_1_1unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1unique__ptr_3_01_t[]_00_01_deleter_01_4.html">unique_ptr&lt; T[], Deleter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> that manages a dynamically-allocated array of objects  <a href="classthrowing_1_1unique__ptr_3_01_t[]_00_01_deleter_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a881b5eadd3ef72778e6b27ffae9a62ee">swap</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a>.  <a href="#a881b5eadd3ef72778e6b27ffae9a62ee">More...</a><br /></td></tr>
<tr class="separator:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff10629d166d6ded4d90ed20000dc62"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aaff10629d166d6ded4d90ed20000dc62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aaff10629d166d6ded4d90ed20000dc62">make_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaff10629d166d6ded4d90ed20000dc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a> using args as the parameter list for the constructor of T.  <a href="#aaff10629d166d6ded4d90ed20000dc62">More...</a><br /></td></tr>
<tr class="separator:aaff10629d166d6ded4d90ed20000dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc , class... Args&gt; </td></tr>
<tr class="memitem:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3db8c15289fa7a842c42b2845aba2fc0">allocate_shared</a> (const Alloc &amp;alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3db8c15289fa7a842c42b2845aba2fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a> using args as the parameter list for the constructor of T.  <a href="#a3db8c15289fa7a842c42b2845aba2fc0">More...</a><br /></td></tr>
<tr class="separator:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab77d69edd95c98820b1dbc8ad6c31665">static_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab77d69edd95c98820b1dbc8ad6c31665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a static_cast expression.  <a href="#ab77d69edd95c98820b1dbc8ad6c31665">More...</a><br /></td></tr>
<tr class="separator:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a4858bfccdab81ea8693887119371"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a491a4858bfccdab81ea8693887119371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a491a4858bfccdab81ea8693887119371">dynamic_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a491a4858bfccdab81ea8693887119371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a dynamic_cast expression.  <a href="#a491a4858bfccdab81ea8693887119371">More...</a><br /></td></tr>
<tr class="separator:a491a4858bfccdab81ea8693887119371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c7042d950278a26182ff742e9d0046"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a29c7042d950278a26182ff742e9d0046"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a29c7042d950278a26182ff742e9d0046">const_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a29c7042d950278a26182ff742e9d0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a const_cast expression.  <a href="#a29c7042d950278a26182ff742e9d0046">More...</a><br /></td></tr>
<tr class="separator:a29c7042d950278a26182ff742e9d0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec28839a72be32c0258b7d60a29b8c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a32ec28839a72be32c0258b7d60a29b8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a32ec28839a72be32c0258b7d60a29b8c">reinterpret_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a32ec28839a72be32c0258b7d60a29b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a reinterpret_cast expression.  <a href="#a32ec28839a72be32c0258b7d60a29b8c">More...</a><br /></td></tr>
<tr class="separator:a32ec28839a72be32c0258b7d60a29b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memTemplParams" colspan="2">template&lt;class Deleter , class T &gt; </td></tr>
<tr class="memitem:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memTemplItemLeft" align="right" valign="top">Deleter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a">get_deleter</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;p) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the p's deleter.  <a href="#a5255215e28b4b2bb9fbee46d1d0ccd0a">More...</a><br /></td></tr>
<tr class="separator:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d2f4cf39bad33572029090b20db719"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a84d2f4cf39bad33572029090b20db719"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a84d2f4cf39bad33572029090b20db719">operator==</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a84d2f4cf39bad33572029090b20db719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a84d2f4cf39bad33572029090b20db719">More...</a><br /></td></tr>
<tr class="separator:a84d2f4cf39bad33572029090b20db719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165ff90955a23e1f59be60117d8fb6d8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a165ff90955a23e1f59be60117d8fb6d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a165ff90955a23e1f59be60117d8fb6d8">operator!=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a165ff90955a23e1f59be60117d8fb6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a165ff90955a23e1f59be60117d8fb6d8">More...</a><br /></td></tr>
<tr class="separator:a165ff90955a23e1f59be60117d8fb6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5a5fcd7bcea837df91a3a8d7af4fa4b3">operator&lt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a5a5fcd7bcea837df91a3a8d7af4fa4b3">More...</a><br /></td></tr>
<tr class="separator:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aba1be6682696149a335eb589aa362"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a83aba1be6682696149a335eb589aa362"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a83aba1be6682696149a335eb589aa362">operator&gt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a83aba1be6682696149a335eb589aa362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a83aba1be6682696149a335eb589aa362">More...</a><br /></td></tr>
<tr class="separator:a83aba1be6682696149a335eb589aa362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f644b2732c39647a76af4d83c5152e"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a55f644b2732c39647a76af4d83c5152e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a55f644b2732c39647a76af4d83c5152e">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a55f644b2732c39647a76af4d83c5152e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a55f644b2732c39647a76af4d83c5152e">More...</a><br /></td></tr>
<tr class="separator:a55f644b2732c39647a76af4d83c5152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad61f697dbd6cd60ea037b3d7ef765781">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad61f697dbd6cd60ea037b3d7ef765781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#ad61f697dbd6cd60ea037b3d7ef765781">More...</a><br /></td></tr>
<tr class="separator:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a40c25a16d8ffb452a3271b26480c4"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a91a40c25a16d8ffb452a3271b26480c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a91a40c25a16d8ffb452a3271b26480c4">operator==</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a91a40c25a16d8ffb452a3271b26480c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a91a40c25a16d8ffb452a3271b26480c4">More...</a><br /></td></tr>
<tr class="separator:a91a40c25a16d8ffb452a3271b26480c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172db12fe0bc00ecae6062701d9a5adc"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a172db12fe0bc00ecae6062701d9a5adc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a172db12fe0bc00ecae6062701d9a5adc">operator!=</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a172db12fe0bc00ecae6062701d9a5adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a172db12fe0bc00ecae6062701d9a5adc">More...</a><br /></td></tr>
<tr class="separator:a172db12fe0bc00ecae6062701d9a5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274f4f24da99d92cbd3e1b4f23419426"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a274f4f24da99d92cbd3e1b4f23419426"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a274f4f24da99d92cbd3e1b4f23419426">operator&lt;</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a274f4f24da99d92cbd3e1b4f23419426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a274f4f24da99d92cbd3e1b4f23419426">More...</a><br /></td></tr>
<tr class="separator:a274f4f24da99d92cbd3e1b4f23419426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81345848320a5d025e581f63a85b3b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1f81345848320a5d025e581f63a85b3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a1f81345848320a5d025e581f63a85b3b">operator&gt;</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1f81345848320a5d025e581f63a85b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a1f81345848320a5d025e581f63a85b3b">More...</a><br /></td></tr>
<tr class="separator:a1f81345848320a5d025e581f63a85b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e00b9afd929217056b886fc06f181c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab8e00b9afd929217056b886fc06f181c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab8e00b9afd929217056b886fc06f181c">operator&lt;=</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8e00b9afd929217056b886fc06f181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#ab8e00b9afd929217056b886fc06f181c">More...</a><br /></td></tr>
<tr class="separator:ab8e00b9afd929217056b886fc06f181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff539f5ddff075e2ae3fa6f9dcc41c4"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0ff539f5ddff075e2ae3fa6f9dcc41c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a0ff539f5ddff075e2ae3fa6f9dcc41c4">operator&gt;=</a> (const std::shared_ptr&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ff539f5ddff075e2ae3fa6f9dcc41c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a0ff539f5ddff075e2ae3fa6f9dcc41c4">More...</a><br /></td></tr>
<tr class="separator:a0ff539f5ddff075e2ae3fa6f9dcc41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643d4440bc92dcbca281f2c7f859534"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6643d4440bc92dcbca281f2c7f859534"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6643d4440bc92dcbca281f2c7f859534">operator==</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6643d4440bc92dcbca281f2c7f859534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a6643d4440bc92dcbca281f2c7f859534">More...</a><br /></td></tr>
<tr class="separator:a6643d4440bc92dcbca281f2c7f859534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade8752aa6aae1d486a2240fba2f805"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1ade8752aa6aae1d486a2240fba2f805"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a1ade8752aa6aae1d486a2240fba2f805">operator!=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1ade8752aa6aae1d486a2240fba2f805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a1ade8752aa6aae1d486a2240fba2f805">More...</a><br /></td></tr>
<tr class="separator:a1ade8752aa6aae1d486a2240fba2f805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe771e9aab61fe048462d9cbe548c0b5"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afe771e9aab61fe048462d9cbe548c0b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#afe771e9aab61fe048462d9cbe548c0b5">operator&lt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:afe771e9aab61fe048462d9cbe548c0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#afe771e9aab61fe048462d9cbe548c0b5">More...</a><br /></td></tr>
<tr class="separator:afe771e9aab61fe048462d9cbe548c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb48797e7b87fca5875bb612534b67d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1eb48797e7b87fca5875bb612534b67d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a1eb48797e7b87fca5875bb612534b67d">operator&gt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1eb48797e7b87fca5875bb612534b67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#a1eb48797e7b87fca5875bb612534b67d">More...</a><br /></td></tr>
<tr class="separator:a1eb48797e7b87fca5875bb612534b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629c089cb50ca30cc9a0280cd31dbec"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab629c089cb50ca30cc9a0280cd31dbec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab629c089cb50ca30cc9a0280cd31dbec">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab629c089cb50ca30cc9a0280cd31dbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#ab629c089cb50ca30cc9a0280cd31dbec">More...</a><br /></td></tr>
<tr class="separator:ab629c089cb50ca30cc9a0280cd31dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0453dba8b663705df6db8e27778ebfd"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae0453dba8b663705df6db8e27778ebfd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ae0453dba8b663705df6db8e27778ebfd">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const std::shared_ptr&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0453dba8b663705df6db8e27778ebfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects.  <a href="#ae0453dba8b663705df6db8e27778ebfd">More...</a><br /></td></tr>
<tr class="separator:ae0453dba8b663705df6db8e27778ebfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf90c9ead79e01fd50379106f306948f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf90c9ead79e01fd50379106f306948f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#acf90c9ead79e01fd50379106f306948f">operator==</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf90c9ead79e01fd50379106f306948f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#acf90c9ead79e01fd50379106f306948f">More...</a><br /></td></tr>
<tr class="separator:acf90c9ead79e01fd50379106f306948f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717cdfe407e14c88b05176954f851176"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a717cdfe407e14c88b05176954f851176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a717cdfe407e14c88b05176954f851176">operator==</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a717cdfe407e14c88b05176954f851176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a717cdfe407e14c88b05176954f851176">More...</a><br /></td></tr>
<tr class="separator:a717cdfe407e14c88b05176954f851176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a0395e3e9d88a2b48ffed79cacc16b47b">operator!=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a0395e3e9d88a2b48ffed79cacc16b47b">More...</a><br /></td></tr>
<tr class="separator:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac0ed2c87317a0797e419c4a799be22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ac0ed2c87317a0797e419c4a799be22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2ac0ed2c87317a0797e419c4a799be22">operator!=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ac0ed2c87317a0797e419c4a799be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a2ac0ed2c87317a0797e419c4a799be22">More...</a><br /></td></tr>
<tr class="separator:a2ac0ed2c87317a0797e419c4a799be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada51131a06c891299eaf3393b9e0febe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada51131a06c891299eaf3393b9e0febe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ada51131a06c891299eaf3393b9e0febe">operator&lt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ada51131a06c891299eaf3393b9e0febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#ada51131a06c891299eaf3393b9e0febe">More...</a><br /></td></tr>
<tr class="separator:ada51131a06c891299eaf3393b9e0febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3a8e5386ada06bb6aadcf89618b6403a">operator&lt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a8e5386ada06bb6aadcf89618b6403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a3a8e5386ada06bb6aadcf89618b6403a">More...</a><br /></td></tr>
<tr class="separator:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5509a8ce6353c8143340e9f90612ef2d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5509a8ce6353c8143340e9f90612ef2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5509a8ce6353c8143340e9f90612ef2d">operator&gt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5509a8ce6353c8143340e9f90612ef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a5509a8ce6353c8143340e9f90612ef2d">More...</a><br /></td></tr>
<tr class="separator:a5509a8ce6353c8143340e9f90612ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5a31a9fef43360d2fd1390eefd98aa44">operator&gt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5a31a9fef43360d2fd1390eefd98aa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a5a31a9fef43360d2fd1390eefd98aa44">More...</a><br /></td></tr>
<tr class="separator:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe304e6d2e73044323e8674f05f0b2c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abfe304e6d2e73044323e8674f05f0b2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#abfe304e6d2e73044323e8674f05f0b2c">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:abfe304e6d2e73044323e8674f05f0b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#abfe304e6d2e73044323e8674f05f0b2c">More...</a><br /></td></tr>
<tr class="separator:abfe304e6d2e73044323e8674f05f0b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b716518505c9332d6cf76df98e883"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c4b716518505c9332d6cf76df98e883"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3c4b716518505c9332d6cf76df98e883">operator&lt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3c4b716518505c9332d6cf76df98e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a3c4b716518505c9332d6cf76df98e883">More...</a><br /></td></tr>
<tr class="separator:a3c4b716518505c9332d6cf76df98e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc0a95868e5576296d1b22d19fece8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1bc0a95868e5576296d1b22d19fece8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad1bc0a95868e5576296d1b22d19fece8">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1bc0a95868e5576296d1b22d19fece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#ad1bc0a95868e5576296d1b22d19fece8">More...</a><br /></td></tr>
<tr class="separator:ad1bc0a95868e5576296d1b22d19fece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a8e32eec1fa39c291d06fb43e1f70915b">operator&gt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8e32eec1fa39c291d06fb43e1f70915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer.  <a href="#a8e32eec1fa39c291d06fb43e1f70915b">More...</a><br /></td></tr>
<tr class="separator:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1c502701c9ac87b6403b3ed3374538"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:a6b1c502701c9ac87b6403b3ed3374538"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6b1c502701c9ac87b6403b3ed3374538">operator&lt;&lt;</a> (std::basic_ostream&lt; U, V &gt; &amp;os, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a6b1c502701c9ac87b6403b3ed3374538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the value of the pointer stored in ptr into the output stream os.  <a href="#a6b1c502701c9ac87b6403b3ed3374538">More...</a><br /></td></tr>
<tr class="separator:a6b1c502701c9ac87b6403b3ed3374538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">atomic_is_lock_free</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; const *p)</td></tr>
<tr class="memdesc:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether atomic access to the shared pointer pointed-to by p is lock-free.  <a href="#a6df8cc4c1a8c526fd69a1faa328e1781">More...</a><br /></td></tr>
<tr class="separator:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e269c7e54c8d1a971177e9765fb31c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a58e269c7e54c8d1a971177e9765fb31c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">atomic_load</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p)</td></tr>
<tr class="memdesc:a58e269c7e54c8d1a971177e9765fb31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst)  <a href="#a58e269c7e54c8d1a971177e9765fb31c">More...</a><br /></td></tr>
<tr class="separator:a58e269c7e54c8d1a971177e9765fb31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124bdb97e54c1920a360638dad128ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af124bdb97e54c1920a360638dad128ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">atomic_load_explicit</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, std::memory_order mo)</td></tr>
<tr class="memdesc:af124bdb97e54c1920a360638dad128ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shared pointer pointed-to by p.  <a href="#af124bdb97e54c1920a360638dad128ec">More...</a><br /></td></tr>
<tr class="separator:af124bdb97e54c1920a360638dad128ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db0aae6446352c8293d7770e70dfd04"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5db0aae6446352c8293d7770e70dfd04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">atomic_store</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r)</td></tr>
<tr class="memdesc:a5db0aae6446352c8293d7770e70dfd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst)  <a href="#a5db0aae6446352c8293d7770e70dfd04">More...</a><br /></td></tr>
<tr class="separator:a5db0aae6446352c8293d7770e70dfd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe627ff91ab06f577d6d7cf94fa94037"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afe627ff91ab06f577d6d7cf94fa94037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">atomic_store_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r, std::memory_order mo)</td></tr>
<tr class="memdesc:afe627ff91ab06f577d6d7cf94fa94037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p-&gt;swap(r).  <a href="#afe627ff91ab06f577d6d7cf94fa94037">More...</a><br /></td></tr>
<tr class="separator:afe627ff91ab06f577d6d7cf94fa94037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d928899e10f34e68868a8d33fbab2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff1d928899e10f34e68868a8d33fbab2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">atomic_exchange</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r)</td></tr>
<tr class="memdesc:aff1d928899e10f34e68868a8d33fbab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_exchange(p, r, memory_order_seq_cst)  <a href="#aff1d928899e10f34e68868a8d33fbab2">More...</a><br /></td></tr>
<tr class="separator:aff1d928899e10f34e68868a8d33fbab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6208465729923d0056ede4ed72e57a7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6208465729923d0056ede4ed72e57a7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">atomic_exchange_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r, std::memory_order mo)</td></tr>
<tr class="memdesc:a6208465729923d0056ede4ed72e57a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly pointed-to by p, atomically.  <a href="#a6208465729923d0056ede4ed72e57a7b">More...</a><br /></td></tr>
<tr class="separator:a6208465729923d0056ede4ed72e57a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dc503001ad62be233dac0a07a49fee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a25dc503001ad62be233dac0a07a49fee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">atomic_compare_exchange_weak</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired)</td></tr>
<tr class="memdesc:a25dc503001ad62be233dac0a07a49fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst)  <a href="#a25dc503001ad62be233dac0a07a49fee">More...</a><br /></td></tr>
<tr class="separator:a25dc503001ad62be233dac0a07a49fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">atomic_compare_exchange_strong</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired)</td></tr>
<tr class="memdesc:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst)  <a href="#aaad0d590db4d1724fd0c21e0f0efedeb">More...</a><br /></td></tr>
<tr class="separator:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">atomic_compare_exchange_strong_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</td></tr>
<tr class="memdesc:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false.  <a href="#ae8f7dfcc23277f4c5dd0d9e22e634076">More...</a><br /></td></tr>
<tr class="separator:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">atomic_compare_exchange_weak_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</td></tr>
<tr class="memdesc:a9189fc5561dbe027149aa1d43f1c3e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false, but may fail spuriously.  <a href="#a9189fc5561dbe027149aa1d43f1c3e00">More...</a><br /></td></tr>
<tr class="separator:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3b16a5f9ca990313f55d3e7e97f5f6ce">make_unique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of non-array type T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> using args as the parameter list for the constructor of T.  <a href="#a3b16a5f9ca990313f55d3e7e97f5f6ce">More...</a><br /></td></tr>
<tr class="separator:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d34307ba83e132a382776a7f85288d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a54d34307ba83e132a382776a7f85288d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Unknown_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a54d34307ba83e132a382776a7f85288d">make_unique</a> (size_t n)</td></tr>
<tr class="memdesc:a54d34307ba83e132a382776a7f85288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array of unknown bound T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>.  <a href="#a54d34307ba83e132a382776a7f85288d">More...</a><br /></td></tr>
<tr class="separator:a54d34307ba83e132a382776a7f85288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Known_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad84d4f349c97d7ef4dc4cb7165bccc68">make_unique</a> (Args &amp;&amp;...)=delete</td></tr>
<tr class="memdesc:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of arrays of known bound is disallowed.  <a href="#ad84d4f349c97d7ef4dc4cb7165bccc68">More...</a><br /></td></tr>
<tr class="separator:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27302980c01b6af6b48aec2f7e6a961a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a27302980c01b6af6b48aec2f7e6a961a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a27302980c01b6af6b48aec2f7e6a961a">operator==</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a27302980c01b6af6b48aec2f7e6a961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a27302980c01b6af6b48aec2f7e6a961a">More...</a><br /></td></tr>
<tr class="separator:a27302980c01b6af6b48aec2f7e6a961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab8f93c25e87c9185589c8c8cecd7f271">operator!=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab8f93c25e87c9185589c8c8cecd7f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#ab8f93c25e87c9185589c8c8cecd7f271">More...</a><br /></td></tr>
<tr class="separator:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302436b7f0fe243a2c1792b37dc096fa"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a302436b7f0fe243a2c1792b37dc096fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a302436b7f0fe243a2c1792b37dc096fa">operator&lt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a302436b7f0fe243a2c1792b37dc096fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a302436b7f0fe243a2c1792b37dc096fa">More...</a><br /></td></tr>
<tr class="separator:a302436b7f0fe243a2c1792b37dc096fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94436f6eb9da1991d95771b51958c2a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:ac94436f6eb9da1991d95771b51958c2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ac94436f6eb9da1991d95771b51958c2a">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac94436f6eb9da1991d95771b51958c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#ac94436f6eb9da1991d95771b51958c2a">More...</a><br /></td></tr>
<tr class="separator:ac94436f6eb9da1991d95771b51958c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee6a539d3b600aa8fec1b928abed915"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a5ee6a539d3b600aa8fec1b928abed915"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5ee6a539d3b600aa8fec1b928abed915">operator&gt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5ee6a539d3b600aa8fec1b928abed915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a5ee6a539d3b600aa8fec1b928abed915">More...</a><br /></td></tr>
<tr class="separator:a5ee6a539d3b600aa8fec1b928abed915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a0974a3f27e1618c8465caadf6f6bda3a">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0974a3f27e1618c8465caadf6f6bda3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a0974a3f27e1618c8465caadf6f6bda3a">More...</a><br /></td></tr>
<tr class="separator:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90ddbd28ae57c717f20232fbc740325"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:aa90ddbd28ae57c717f20232fbc740325"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aa90ddbd28ae57c717f20232fbc740325">operator==</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa90ddbd28ae57c717f20232fbc740325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#aa90ddbd28ae57c717f20232fbc740325">More...</a><br /></td></tr>
<tr class="separator:aa90ddbd28ae57c717f20232fbc740325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171e763dd062f5811881f30f5047c445"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a171e763dd062f5811881f30f5047c445"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a171e763dd062f5811881f30f5047c445">operator!=</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a171e763dd062f5811881f30f5047c445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a171e763dd062f5811881f30f5047c445">More...</a><br /></td></tr>
<tr class="separator:a171e763dd062f5811881f30f5047c445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ab4471c3426913062e1a4de830553"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a1c0ab4471c3426913062e1a4de830553"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a1c0ab4471c3426913062e1a4de830553">operator&lt;</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1c0ab4471c3426913062e1a4de830553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a1c0ab4471c3426913062e1a4de830553">More...</a><br /></td></tr>
<tr class="separator:a1c0ab4471c3426913062e1a4de830553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4061edea19f4806f676508151e8a3b"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a9a4061edea19f4806f676508151e8a3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9a4061edea19f4806f676508151e8a3b">operator&lt;=</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9a4061edea19f4806f676508151e8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a9a4061edea19f4806f676508151e8a3b">More...</a><br /></td></tr>
<tr class="separator:a9a4061edea19f4806f676508151e8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9978848446c7f48eedabf20212e67763"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a9978848446c7f48eedabf20212e67763"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9978848446c7f48eedabf20212e67763">operator&gt;</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9978848446c7f48eedabf20212e67763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a9978848446c7f48eedabf20212e67763">More...</a><br /></td></tr>
<tr class="separator:a9978848446c7f48eedabf20212e67763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1dafe77868e3261239742d427f423e"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a4c1dafe77868e3261239742d427f423e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a4c1dafe77868e3261239742d427f423e">operator&gt;=</a> (const std::unique_ptr&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4c1dafe77868e3261239742d427f423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a4c1dafe77868e3261239742d427f423e">More...</a><br /></td></tr>
<tr class="separator:a4c1dafe77868e3261239742d427f423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949572a85183ad06969ae03a541e8f93"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a949572a85183ad06969ae03a541e8f93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a949572a85183ad06969ae03a541e8f93">operator==</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a949572a85183ad06969ae03a541e8f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a949572a85183ad06969ae03a541e8f93">More...</a><br /></td></tr>
<tr class="separator:a949572a85183ad06969ae03a541e8f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918cd308310cc190b80993d2d20eeb64"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a918cd308310cc190b80993d2d20eeb64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a918cd308310cc190b80993d2d20eeb64">operator!=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a918cd308310cc190b80993d2d20eeb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a918cd308310cc190b80993d2d20eeb64">More...</a><br /></td></tr>
<tr class="separator:a918cd308310cc190b80993d2d20eeb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6113be0d2ece501070dd698f6d5366"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a3b6113be0d2ece501070dd698f6d5366"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3b6113be0d2ece501070dd698f6d5366">operator&lt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3b6113be0d2ece501070dd698f6d5366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a3b6113be0d2ece501070dd698f6d5366">More...</a><br /></td></tr>
<tr class="separator:a3b6113be0d2ece501070dd698f6d5366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b092623f337fc97002f4d613850cb01"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a9b092623f337fc97002f4d613850cb01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9b092623f337fc97002f4d613850cb01">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9b092623f337fc97002f4d613850cb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a9b092623f337fc97002f4d613850cb01">More...</a><br /></td></tr>
<tr class="separator:a9b092623f337fc97002f4d613850cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2e4cf1af83c415080ba9f979fa5c8a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:afd2e4cf1af83c415080ba9f979fa5c8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#afd2e4cf1af83c415080ba9f979fa5c8a">operator&gt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd2e4cf1af83c415080ba9f979fa5c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#afd2e4cf1af83c415080ba9f979fa5c8a">More...</a><br /></td></tr>
<tr class="separator:afd2e4cf1af83c415080ba9f979fa5c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed541e9f2a7d6c1649467d21db0b512"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a3ed541e9f2a7d6c1649467d21db0b512"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3ed541e9f2a7d6c1649467d21db0b512">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const std::unique_ptr&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3ed541e9f2a7d6c1649467d21db0b512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a3ed541e9f2a7d6c1649467d21db0b512">More...</a><br /></td></tr>
<tr class="separator:a3ed541e9f2a7d6c1649467d21db0b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b9419192adc27bb8a8506122b1f0d5"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a46b9419192adc27bb8a8506122b1f0d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a46b9419192adc27bb8a8506122b1f0d5">operator==</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a46b9419192adc27bb8a8506122b1f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a46b9419192adc27bb8a8506122b1f0d5">More...</a><br /></td></tr>
<tr class="separator:a46b9419192adc27bb8a8506122b1f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a04c9545fb0dcbb28d724f508d7e042b7">operator==</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04c9545fb0dcbb28d724f508d7e042b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a04c9545fb0dcbb28d724f508d7e042b7">More...</a><br /></td></tr>
<tr class="separator:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e62c6df7d6956d39b91807898912120"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a9e62c6df7d6956d39b91807898912120"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9e62c6df7d6956d39b91807898912120">operator!=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9e62c6df7d6956d39b91807898912120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a9e62c6df7d6956d39b91807898912120">More...</a><br /></td></tr>
<tr class="separator:a9e62c6df7d6956d39b91807898912120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679fdd252caae096dd6d71b192564fb0"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a679fdd252caae096dd6d71b192564fb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a679fdd252caae096dd6d71b192564fb0">operator!=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a679fdd252caae096dd6d71b192564fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a679fdd252caae096dd6d71b192564fb0">More...</a><br /></td></tr>
<tr class="separator:a679fdd252caae096dd6d71b192564fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#adbaed90b4b8e62cef2fdd4428acfa840">operator&lt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:adbaed90b4b8e62cef2fdd4428acfa840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#adbaed90b4b8e62cef2fdd4428acfa840">More...</a><br /></td></tr>
<tr class="separator:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358041bb7ae757f06ce0849208bb2ed"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a2358041bb7ae757f06ce0849208bb2ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2358041bb7ae757f06ce0849208bb2ed">operator&lt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2358041bb7ae757f06ce0849208bb2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a2358041bb7ae757f06ce0849208bb2ed">More...</a><br /></td></tr>
<tr class="separator:a2358041bb7ae757f06ce0849208bb2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6448b3a2571d02388459c38014c3e85d"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a6448b3a2571d02388459c38014c3e85d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6448b3a2571d02388459c38014c3e85d">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:a6448b3a2571d02388459c38014c3e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a6448b3a2571d02388459c38014c3e85d">More...</a><br /></td></tr>
<tr class="separator:a6448b3a2571d02388459c38014c3e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa527891d4d0d1578e944c245db5344"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a5fa527891d4d0d1578e944c245db5344"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5fa527891d4d0d1578e944c245db5344">operator&lt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5fa527891d4d0d1578e944c245db5344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a5fa527891d4d0d1578e944c245db5344">More...</a><br /></td></tr>
<tr class="separator:a5fa527891d4d0d1578e944c245db5344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a51282cc1ffc3a25f8b87771ee73111e7">operator&gt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:a51282cc1ffc3a25f8b87771ee73111e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a51282cc1ffc3a25f8b87771ee73111e7">More...</a><br /></td></tr>
<tr class="separator:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20c90d8238abbfc43c58847d16d29e"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a2d20c90d8238abbfc43c58847d16d29e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2d20c90d8238abbfc43c58847d16d29e">operator&gt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2d20c90d8238abbfc43c58847d16d29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a2d20c90d8238abbfc43c58847d16d29e">More...</a><br /></td></tr>
<tr class="separator:a2d20c90d8238abbfc43c58847d16d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c13caed76fa587fe35ab57dda17c4"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:aac1c13caed76fa587fe35ab57dda17c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aac1c13caed76fa587fe35ab57dda17c4">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:aac1c13caed76fa587fe35ab57dda17c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#aac1c13caed76fa587fe35ab57dda17c4">More...</a><br /></td></tr>
<tr class="separator:aac1c13caed76fa587fe35ab57dda17c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aa1a2bf209ee2771fb4ea401c297d56c6">operator&gt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#aa1a2bf209ee2771fb4ea401c297d56c6">More...</a><br /></td></tr>
<tr class="separator:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecd94b4b26224031f43e39a282a74b7"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Y , class D &gt; </td></tr>
<tr class="memitem:adecd94b4b26224031f43e39a282a74b7"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#adecd94b4b26224031f43e39a282a74b7">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; Y, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:adecd94b4b26224031f43e39a282a74b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the value of the pointer stored in ptr into the output stream os.  <a href="#adecd94b4b26224031f43e39a282a74b7">More...</a><br /></td></tr>
<tr class="separator:adecd94b4b26224031f43e39a282a74b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">swap</a> (<a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>.  <a href="#aa33cc870cf4266ac52c8fb07a295bbeb">More...</a><br /></td></tr>
<tr class="separator:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementations of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a>, <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> and related. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3db8c15289fa7a842c42b2845aba2fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db8c15289fa7a842c42b2845aba2fc0">&#9670;&nbsp;</a></span>allocate_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>The object is constructed as if by the expression std::allocator_traits&lt;A2&gt;::construct(a, pv, v)), where pv is an internal void* pointer to storage suitable to hold an object of type T and a is the possibly-rebound copy of the allocator.</p>
<p>The storage is typically larger than sizeof(T) in order to use one allocation for both the control block of the shared pointer and the T object.</p>
<p>The <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> constructor called by this function enables shared_from_this with a pointer to the newly constructed object of type T.</p>
<p>All memory allocation is done using a copy of alloc, which must satisfy the Allocator requirements.</p>
<p>This overload only participates in overload resolution if T is not an array type </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00583">583</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                                                                   {</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(std::move(</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            std::allocate_shared&lt;T&gt;(alloc, std::forward&lt;Args&gt;(args)...)));</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaad0d590db4d1724fd0c21e0f0efedeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad0d590db4d1724fd0c21e0f0efedeb">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01035">1035</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                                                           {</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">atomic_compare_exchange_strong</a>(</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            desired.get_std_shared_ptr());</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_aaad0d590db4d1724fd0c21e0f0efedeb"><div class="ttname"><a href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">throwing::atomic_compare_exchange_strong</a></div><div class="ttdeci">bool atomic_compare_exchange_strong(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired)</div><div class="ttdoc">Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01035">shared_ptr.hpp:1035</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8f7dfcc23277f4c5dd0d9e22e634076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f7dfcc23277f4c5dd0d9e22e634076">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_strong_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01051">1051</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                                                                      {</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">atomic_compare_exchange_strong_explicit</a>(</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;            desired.get_std_shared_ptr(), success, failure);</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_ae8f7dfcc23277f4c5dd0d9e22e634076"><div class="ttname"><a href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">throwing::atomic_compare_exchange_strong_explicit</a></div><div class="ttdeci">bool atomic_compare_exchange_strong_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</div><div class="ttdoc">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same poi...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01051">shared_ptr.hpp:1051</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a25dc503001ad62be233dac0a07a49fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dc503001ad62be233dac0a07a49fee">&#9670;&nbsp;</a></span>atomic_compare_exchange_weak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_weak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01023">1023</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                                                         {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">atomic_compare_exchange_weak</a>(</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;            desired.get_std_shared_ptr());</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a25dc503001ad62be233dac0a07a49fee"><div class="ttname"><a href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">throwing::atomic_compare_exchange_weak</a></div><div class="ttdeci">bool atomic_compare_exchange_weak(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired)</div><div class="ttdoc">Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01023">shared_ptr.hpp:1023</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9189fc5561dbe027149aa1d43f1c3e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9189fc5561dbe027149aa1d43f1c3e00">&#9670;&nbsp;</a></span>atomic_compare_exchange_weak_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_weak_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false, but may fail spuriously. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01070">1070</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;                                                                    {</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">atomic_compare_exchange_weak_explicit</a>(</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;            desired.get_std_shared_ptr(), success, failure);</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a9189fc5561dbe027149aa1d43f1c3e00"><div class="ttname"><a href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">throwing::atomic_compare_exchange_weak_explicit</a></div><div class="ttdeci">bool atomic_compare_exchange_weak_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</div><div class="ttdoc">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same poi...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01070">shared_ptr.hpp:1070</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff1d928899e10f34e68868a8d33fbab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1d928899e10f34e68868a8d33fbab2">&#9670;&nbsp;</a></span>atomic_exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_exchange(p, r, memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01001">1001</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                                                                 {</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <span class="keywordflow">return</span> std::move(<a class="code" href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">atomic_exchange</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                                     r.get_std_shared_ptr()));</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_aff1d928899e10f34e68868a8d33fbab2"><div class="ttname"><a href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">throwing::atomic_exchange</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_exchange(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r)</div><div class="ttdoc">Equivalent to atomic_exchange(p, r, memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01001">shared_ptr.hpp:1001</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6208465729923d0056ede4ed72e57a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6208465729923d0056ede4ed72e57a7b">&#9670;&nbsp;</a></span>atomic_exchange_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_exchange_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly pointed-to by p, atomically. </p>
<p>Effectively executes p-&gt;swap(r) and returns a copy of r after the swap. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l01012">1012</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                                                           {</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    <span class="keywordflow">return</span> std::move(</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;            <a class="code" href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">atomic_exchange_explicit</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                                     r.get_std_shared_ptr(), mo));</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a6208465729923d0056ede4ed72e57a7b"><div class="ttname"><a href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">throwing::atomic_exchange_explicit</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_exchange_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r, std::memory_order mo)</div><div class="ttdoc">Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly poin...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l01012">shared_ptr.hpp:1012</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6df8cc4c1a8c526fd69a1faa328e1781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df8cc4c1a8c526fd69a1faa328e1781">&#9670;&nbsp;</a></span>atomic_is_lock_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_is_lock_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether atomic access to the shared pointer pointed-to by p is lock-free. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00955">955</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                                                                    {</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">atomic_is_lock_free</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; <span class="keyword">const </span>*<span class="keyword">&gt;</span>(p));</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a6df8cc4c1a8c526fd69a1faa328e1781"><div class="ttname"><a href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">throwing::atomic_is_lock_free</a></div><div class="ttdeci">bool atomic_is_lock_free(shared_ptr&lt; T &gt; const *p)</div><div class="ttdoc">Determines whether atomic access to the shared pointer pointed-to by p is lock-free. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00955">shared_ptr.hpp:955</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a58e269c7e54c8d1a971177e9765fb31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e269c7e54c8d1a971177e9765fb31c">&#9670;&nbsp;</a></span>atomic_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00961">961</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                                                                     {</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;    <span class="keywordflow">return</span> std::move(</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;            <a class="code" href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">atomic_load</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p)));</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a58e269c7e54c8d1a971177e9765fb31c"><div class="ttname"><a href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">throwing::atomic_load</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_load(const shared_ptr&lt; T &gt; *p)</div><div class="ttdoc">Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00961">shared_ptr.hpp:961</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af124bdb97e54c1920a360638dad128ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af124bdb97e54c1920a360638dad128ec">&#9670;&nbsp;</a></span>atomic_load_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shared pointer pointed-to by p. </p>
<p>As with the non-specialized std::atomic_load_explicit, mo cannot be std::memory_order_release or std::memory_order_acq_rel </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00972">972</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                                                       {</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    <span class="keywordflow">return</span> std::move(<a class="code" href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">atomic_load_explicit</a>(</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p), mo));</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_af124bdb97e54c1920a360638dad128ec"><div class="ttname"><a href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">throwing::atomic_load_explicit</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_load_explicit(const shared_ptr&lt; T &gt; *p, std::memory_order mo)</div><div class="ttdoc">Returns the shared pointer pointed-to by p. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00972">shared_ptr.hpp:972</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5db0aae6446352c8293d7770e70dfd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db0aae6446352c8293d7770e70dfd04">&#9670;&nbsp;</a></span>atomic_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::atomic_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00980">980</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                                                                        {</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    <a class="code" href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">atomic_store</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;                 r.get_std_shared_ptr());</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a5db0aae6446352c8293d7770e70dfd04"><div class="ttname"><a href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">throwing::atomic_store</a></div><div class="ttdeci">void atomic_store(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r)</div><div class="ttdoc">Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00980">shared_ptr.hpp:980</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afe627ff91ab06f577d6d7cf94fa94037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe627ff91ab06f577d6d7cf94fa94037">&#9670;&nbsp;</a></span>atomic_store_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p-&gt;swap(r). </p>
<p>As with the non-specialized std::atomic_store_explicit, mo cannot be std::memory_order_acquire or std::memory_order_acq_rel. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00992">992</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                                               {</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <a class="code" href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">atomic_store_explicit</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                          r.get_std_shared_ptr(), mo);</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_afe627ff91ab06f577d6d7cf94fa94037"><div class="ttname"><a href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">throwing::atomic_store_explicit</a></div><div class="ttdeci">void atomic_store_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r, std::memory_order mo)</div><div class="ttdoc">Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00992">shared_ptr.hpp:992</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a29c7042d950278a26182ff742e9d0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c7042d950278a26182ff742e9d0046">&#9670;&nbsp;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a const_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless const_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00638">638</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                                                                      {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">const_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a491a4858bfccdab81ea8693887119371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a4858bfccdab81ea8693887119371">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a dynamic_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> will share ownership with r, except that it is empty if the dynamic_cast performed by dynamic_pointer_cast returns a null pointer.</p>
<p>The behavior is undefined unless dynamic_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00618">618</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                                                                        {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> p =</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                <span class="keyword">dynamic_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get())) {</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        <span class="keywordflow">return</span> shared_ptr&lt;T&gt;();</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5255215e28b4b2bb9fbee46d1d0ccd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255215e28b4b2bb9fbee46d1d0ccd0a">&#9670;&nbsp;</a></span>get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Deleter , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Deleter* throwing::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to the p's deleter. </p>
<p>If the shared pointer p owns a deleter of type cv-unqualified Deleter (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00668">668</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                                                          {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keywordflow">return</span> std::get_deleter&lt;Deleter&gt;(p.get_std_shared_ptr());</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaff10629d166d6ded4d90ed20000dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff10629d166d6ded4d90ed20000dc62">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::make_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>The object is constructed as if by the expression ::new (pv) T(std::forward&lt;Args&gt;(args)...), where pv is an internal void* pointer to storage suitable to hold an object of type T.</p>
<p>The storage is typically larger than sizeof(T) in order to use one allocation for both the control block of the shared pointer and the T object.</p>
<p>The <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> constructor called by this function enables shared_from_this with a pointer to the newly constructed object of type T.</p>
<p>This overload only participates in overload resolution if T is not an array type </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00557">557</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                                                                             {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;            std::move(std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...)));</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3b16a5f9ca990313f55d3e7e97f5f6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b16a5f9ca990313f55d3e7e97f5f6ce">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Single_object throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of non-array type T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>Equivalent to: unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))</p>
<p>This overload only participates in overload resolution if T is not an array type. </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00694">694</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                                                                        {</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    <span class="keywordflow">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...));</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a54d34307ba83e132a382776a7f85288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d34307ba83e132a382776a7f85288d">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Unknown_bound throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an array of unknown bound T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>. </p>
<p>Equivalent to: unique_ptr&lt;T&gt;(new typename std::remove_extent&lt;T&gt;::type[size]())</p>
<p>This overload only participates in overload resolution if T is an array of unknown bound. </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00708">708</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                                                                 {</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type U;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="keywordflow">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> U[n]());</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad84d4f349c97d7ef4dc4cb7165bccc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84d4f349c97d7ef4dc4cb7165bccc68">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Known_bound throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction of arrays of known bound is disallowed. </p>

</div>
</div>
<a id="a165ff90955a23e1f59be60117d8fb6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165ff90955a23e1f59be60117d8fb6d8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs == rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00685">685</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                                                       {</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() != rhs.get_std_shared_ptr();</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab8f93c25e87c9185589c8c8cecd7f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f93c25e87c9185589c8c8cecd7f271">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs.get() == rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00730">730</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                                                                              {</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() != rhs.get_std_unique_ptr();</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a172db12fe0bc00ecae6062701d9a5adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172db12fe0bc00ecae6062701d9a5adc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs == rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00741">741</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                                                       {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_shared_ptr();</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a171e763dd062f5811881f30f5047c445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171e763dd062f5811881f30f5047c445">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs.get() == rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00781">781</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                                               {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_unique_ptr();</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1ade8752aa6aae1d486a2240fba2f805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade8752aa6aae1d486a2240fba2f805">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs == rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00797">797</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                                                          {</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() != rhs;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a918cd308310cc190b80993d2d20eeb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918cd308310cc190b80993d2d20eeb64">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs.get() == rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00837">837</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;                                                  {</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() != rhs;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0395e3e9d88a2b48ffed79cacc16b47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0395e3e9d88a2b48ffed79cacc16b47b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00860">860</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                                                                         {</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() != rhs;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2ac0ed2c87317a0797e419c4a799be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac0ed2c87317a0797e419c4a799be22">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00868">868</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                                                                         {</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_shared_ptr();</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9e62c6df7d6956d39b91807898912120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e62c6df7d6956d39b91807898912120">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00900">900</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                                                                            {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() != rhs;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a679fdd252caae096dd6d71b192564fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679fdd252caae096dd6d71b192564fb0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00908">908</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                                                                            {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_unique_ptr();</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5a5fcd7bcea837df91a3a8d7af4fa4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5fcd7bcea837df91a3a8d7af4fa4b3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;V&gt;()(lhs.get(), rhs.get()), where V is the composite pointer type of std::shared_ptr&lt;T&gt;::element_type* and std::shared_ptr&lt;U&gt;::element_type* </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00696">696</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                                                      {</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a302436b7f0fe243a2c1792b37dc096fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302436b7f0fe243a2c1792b37dc096fa">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;CT&gt;()(lhs.get(), rhs.get()), where CT is std::common_type&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T1, D1&gt;::pointer</a>, <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a>&lt;T2, D2&gt;::pointer&gt;::type </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00740">740</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                                                                             {</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a274f4f24da99d92cbd3e1b4f23419426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274f4f24da99d92cbd3e1b4f23419426">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;V&gt;()(lhs.get(), rhs.get()), where V is the composite pointer type of std::shared_ptr&lt;T&gt;::element_type* and std::shared_ptr&lt;U&gt;::element_type* </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00752">752</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                                                      {</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1c0ab4471c3426913062e1a4de830553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0ab4471c3426913062e1a4de830553">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;CT&gt;()(lhs.get(), rhs.get()), where CT is std::common_type&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T1, D1&gt;::pointer</a>, <a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T2,D2&gt;::pointer</a>&gt;::type </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00792">792</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                                              {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="afe771e9aab61fe048462d9cbe548c0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe771e9aab61fe048462d9cbe548c0b5">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;V&gt;()(lhs.get(), rhs.get()), where V is the composite pointer type of std::shared_ptr&lt;T&gt;::element_type* and std::shared_ptr&lt;U&gt;::element_type* </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00808">808</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                                                         {</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt; rhs;</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3b6113be0d2ece501070dd698f6d5366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6113be0d2ece501070dd698f6d5366">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;CT&gt;()(lhs.get(), rhs.get()), where CT is std::common_type&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T1, D1&gt;::pointer</a>, <a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T2,D2&gt;::pointer</a>&gt;::type </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00848">848</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                                                 {</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt; rhs;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ada51131a06c891299eaf3393b9e0febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada51131a06c891299eaf3393b9e0febe">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2" title="the type pointed to. ">shared_ptr&lt;T&gt;::element_type</a>*&gt;()(lhs.get(), nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00876">876</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                                                                        {</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt; rhs;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3a8e5386ada06bb6aadcf89618b6403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e5386ada06bb6aadcf89618b6403a">&#9670;&nbsp;</a></span>operator<() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2" title="the type pointed to. ">shared_ptr&lt;T&gt;::element_type</a>*&gt;()(nullptr, rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00884">884</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                                                                        {</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="adbaed90b4b8e62cef2fdd4428acfa840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaed90b4b8e62cef2fdd4428acfa840">&#9670;&nbsp;</a></span>operator<() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T,D&gt;::pointer</a>&gt;()(lhs.get(), nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00916">916</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;                                                              {</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt; rhs;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2358041bb7ae757f06ce0849208bb2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358041bb7ae757f06ce0849208bb2ed">&#9670;&nbsp;</a></span>operator<() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0" title="type of the pointer to the pointed object. ">unique_ptr&lt;T,D&gt;::pointer</a>&gt;()(nullptr, rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00924">924</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                                                              {</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6b1c502701c9ac87b6403b3ed3374538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1c502701c9ac87b6403b3ed3374538">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;U, V&gt;&amp; throwing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the value of the pointer stored in ptr into the output stream os. </p>
<p>Equivalent to os &lt;&lt; ptr.get(). </p><dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00943">943</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                                                               {</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    os &lt;&lt; ptr.get();</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="adecd94b4b26224031f43e39a282a74b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd94b4b26224031f43e39a282a74b7">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Y , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT, Traits&gt;&amp; throwing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; Y, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the value of the pointer stored in ptr into the output stream os. </p>
<p>Equivalent to os &lt;&lt; ptr.get(). </p><dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00984">984</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                                                                             {</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    os &lt;&lt; ptr.get();</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a55f644b2732c39647a76af4d83c5152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f644b2732c39647a76af4d83c5152e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00714">714</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                                                       {</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac94436f6eb9da1991d95771b51958c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94436f6eb9da1991d95771b51958c2a">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00748">748</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                                                                              {</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab8e00b9afd929217056b886fc06f181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e00b9afd929217056b886fc06f181c">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00770">770</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                                                       {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9a4061edea19f4806f676508151e8a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4061edea19f4806f676508151e8a3b">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00801">801</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                                               {</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab629c089cb50ca30cc9a0280cd31dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629c089cb50ca30cc9a0280cd31dbec">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00826">826</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                                                          {</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt;= rhs;</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9b092623f337fc97002f4d613850cb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b092623f337fc97002f4d613850cb01">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00857">857</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                                                  {</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt;= rhs;</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="abfe304e6d2e73044323e8674f05f0b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe304e6d2e73044323e8674f05f0b2c">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00908">908</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                                                                         {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt;= rhs;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3c4b716518505c9332d6cf76df98e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b716518505c9332d6cf76df98e883">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00916">916</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;                                                                         {</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6448b3a2571d02388459c38014c3e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6448b3a2571d02388459c38014c3e85d">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00932">932</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                                                               {</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt;= rhs;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5fa527891d4d0d1578e944c245db5344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa527891d4d0d1578e944c245db5344">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00940">940</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                                                               {</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a84d2f4cf39bad33572029090b20db719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d2f4cf39bad33572029090b20db719">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00676">676</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                                                       {</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() == rhs.get_std_shared_ptr();</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a27302980c01b6af6b48aec2f7e6a961a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27302980c01b6af6b48aec2f7e6a961a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00722">722</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                                                                              {</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() == rhs.get_std_unique_ptr();</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a91a40c25a16d8ffb452a3271b26480c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a40c25a16d8ffb452a3271b26480c4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00732">732</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                                                       {</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_shared_ptr();</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa90ddbd28ae57c717f20232fbc740325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90ddbd28ae57c717f20232fbc740325">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00772">772</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                                               {</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_unique_ptr();</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6643d4440bc92dcbca281f2c7f859534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6643d4440bc92dcbca281f2c7f859534">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00788">788</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                                                          {</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() == rhs;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a949572a85183ad06969ae03a541e8f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949572a85183ad06969ae03a541e8f93">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00828">828</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;                                                  {</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() == rhs;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="acf90c9ead79e01fd50379106f306948f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf90c9ead79e01fd50379106f306948f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00844">844</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                                                                         {</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() == rhs;</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a717cdfe407e14c88b05176954f851176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717cdfe407e14c88b05176954f851176">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00852">852</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                                                                         {</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_shared_ptr();</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a46b9419192adc27bb8a8506122b1f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b9419192adc27bb8a8506122b1f0d5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00884">884</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                                                                            {</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() == rhs;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a04c9545fb0dcbb28d724f508d7e042b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c9545fb0dcbb28d724f508d7e042b7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00892">892</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                                                                            {</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_unique_ptr();</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a83aba1be6682696149a335eb589aa362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aba1be6682696149a335eb589aa362">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00705">705</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                                                      {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5ee6a539d3b600aa8fec1b928abed915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee6a539d3b600aa8fec1b928abed915">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00756">756</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                                                                             {</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1f81345848320a5d025e581f63a85b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f81345848320a5d025e581f63a85b3b">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00761">761</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                                                      {</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9978848446c7f48eedabf20212e67763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9978848446c7f48eedabf20212e67763">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00810">810</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                                              {</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1eb48797e7b87fca5875bb612534b67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb48797e7b87fca5875bb612534b67d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00817">817</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                                                         {</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt; rhs;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="afd2e4cf1af83c415080ba9f979fa5c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2e4cf1af83c415080ba9f979fa5c8a">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00866">866</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                                                 {</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt; rhs;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5509a8ce6353c8143340e9f90612ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5509a8ce6353c8143340e9f90612ef2d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>nullptr &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00892">892</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                                                                        {</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt; rhs;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5a31a9fef43360d2fd1390eefd98aa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a31a9fef43360d2fd1390eefd98aa44">&#9670;&nbsp;</a></span>operator>() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; nullptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00900">900</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                                                                        {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a51282cc1ffc3a25f8b87771ee73111e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51282cc1ffc3a25f8b87771ee73111e7">&#9670;&nbsp;</a></span>operator>() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>nullptr &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00948">948</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                                                              {</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt; rhs;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2d20c90d8238abbfc43c58847d16d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d20c90d8238abbfc43c58847d16d29e">&#9670;&nbsp;</a></span>operator>() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; nullptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00956">956</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                                                              {</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad61f697dbd6cd60ea037b3d7ef765781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61f697dbd6cd60ea037b3d7ef765781">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00723">723</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                                                       {</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0974a3f27e1618c8465caadf6f6bda3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0974a3f27e1618c8465caadf6f6bda3a">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00764">764</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                                                                              {</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0ff539f5ddff075e2ae3fa6f9dcc41c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff539f5ddff075e2ae3fa6f9dcc41c4">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00779">779</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                                                       {</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4c1dafe77868e3261239742d427f423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1dafe77868e3261239742d427f423e">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00819">819</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                                               {</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae0453dba8b663705df6db8e27778ebfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0453dba8b663705df6db8e27778ebfd">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00835">835</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                                                          {</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt;= rhs;</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3ed541e9f2a7d6c1649467d21db0b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed541e9f2a7d6c1649467d21db0b512">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00875">875</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                                                  {</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt;= rhs;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad1bc0a95868e5576296d1b22d19fece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc0a95868e5576296d1b22d19fece8">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00924">924</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                                                                         {</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt;= rhs;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8e32eec1fa39c291d06fb43e1f70915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e32eec1fa39c291d06fb43e1f70915b">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00932">932</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                                                                         {</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aac1c13caed76fa587fe35ab57dda17c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1c13caed76fa587fe35ab57dda17c4">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00964">964</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                                                               {</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt;= rhs;</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa1a2bf209ee2771fb4ea401c297d56c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a2bf209ee2771fb4ea401c297d56c6">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00972">972</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                                                               {</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a32ec28839a72be32c0258b7d60a29b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ec28839a72be32c0258b7d60a29b8c">&#9670;&nbsp;</a></span>reinterpret_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a reinterpret_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless reinterpret_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00655">655</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                                                                            {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">reinterpret_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab77d69edd95c98820b1dbc8ad6c31665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77d69edd95c98820b1dbc8ad6c31665">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a static_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless static_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00599">599</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                                                                       {</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">static_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a881b5eadd3ef72778e6b27ffae9a62ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881b5eadd3ef72778e6b27ffae9a62ee">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1shared__ptr.html" title="Wrapper aroung std::shared_ptr that throws when a wrapped null pointer is dereferenced. ">throwing::shared_ptr</a>. </p>
<p>Swaps the pointers of lhs and rhs.</p>
<p>Calls lhs.swap(rhs). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00536">536</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                                                   {</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    lhs.<a class="code" href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">swap</a>(rhs);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;}</div><div class="ttc" id="classthrowing_1_1shared__ptr_html_aad9e2abb060d2a13f3567f9ce045c153"><div class="ttname"><a href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">throwing::shared_ptr::swap</a></div><div class="ttdeci">void swap(shared_ptr &amp;r) TSP_NOEXCEPT</div><div class="ttdoc">Exchanges the contents of *this and r. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00344">shared_ptr.hpp:344</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa33cc870cf4266ac52c8fb07a295bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33cc870cf4266ac52c8fb07a295bbeb">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>. </p>
<p>Swaps the pointers of lhs and rhs.</p>
<p>Calls lhs.swap(rhs).</p>
<p>This function does not participate in overload resolution unless std::is_swappable&lt;D&gt;::value is true. (since C++17) </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00999">999</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                                                   {</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <a class="code" href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">std::swap</a>(lhs.<a class="code" href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">get_std_unique_ptr</a>(), rhs.<a class="code" href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">get_std_unique_ptr</a>());</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;}</div><div class="ttc" id="classthrowing_1_1unique__ptr_html_a4ee6474d93c02bc7189a941a4a2637f1"><div class="ttname"><a href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">throwing::unique_ptr::get_std_unique_ptr</a></div><div class="ttdeci">std_unique_ptr_type &amp; get_std_unique_ptr() TSP_NOEXCEPT</div><div class="ttdoc">Returns reference to the wrapped std::unique_ptr. </div><div class="ttdef"><b>Definition:</b> <a href="unique__ptr_8hpp_source.html#l00297">unique_ptr.hpp:297</a></div></div>
<div class="ttc" id="namespacethrowing_html_aa33cc870cf4266ac52c8fb07a295bbeb"><div class="ttname"><a href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">throwing::swap</a></div><div class="ttdeci">void swap(throwing::unique_ptr&lt; T &gt; &amp;lhs, throwing::unique_ptr&lt; T &gt; &amp;rhs) TSP_NOEXCEPT</div><div class="ttdoc">Specializes the std::swap algorithm for throwing::unique_ptr. </div><div class="ttdef"><b>Definition:</b> <a href="unique__ptr_8hpp_source.html#l00999">unique_ptr.hpp:999</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
