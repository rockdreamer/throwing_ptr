<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>throwing_ptr: throwing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">throwing_ptr
   </div>
   <div id="projectbrief">Smart pointers that throw on dereference if null</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">throwing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacethrowing_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrowing_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1base__null__ptr__exception.html">base_null_ptr_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown upon dereferencing a null <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>.  <a href="classthrowing_1_1base__null__ptr__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1null__ptr__exception.html">null_ptr_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown upon dereferencing a null <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>.  <a href="classthrowing_1_1null__ptr__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> that manages a single object  <a href="classthrowing_1_1unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrowing_1_1unique__ptr_3_01_t[]_00_01_deleter_01_4.html">unique_ptr&lt; T[], Deleter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> that manages a dynamically-allocated array of objects  <a href="classthrowing_1_1unique__ptr_3_01_t[]_00_01_deleter_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a881b5eadd3ef72778e6b27ffae9a62ee">swap</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>.  <a href="#a881b5eadd3ef72778e6b27ffae9a62ee">More...</a><br /></td></tr>
<tr class="separator:a881b5eadd3ef72778e6b27ffae9a62ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff10629d166d6ded4d90ed20000dc62"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aaff10629d166d6ded4d90ed20000dc62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aaff10629d166d6ded4d90ed20000dc62">make_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaff10629d166d6ded4d90ed20000dc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a> using args as the parameter list for the constructor of T.  <a href="#aaff10629d166d6ded4d90ed20000dc62">More...</a><br /></td></tr>
<tr class="separator:aaff10629d166d6ded4d90ed20000dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc , class... Args&gt; </td></tr>
<tr class="memitem:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3db8c15289fa7a842c42b2845aba2fc0">allocate_shared</a> (const Alloc &amp;alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3db8c15289fa7a842c42b2845aba2fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a> using args as the parameter list for the constructor of T.  <a href="#a3db8c15289fa7a842c42b2845aba2fc0">More...</a><br /></td></tr>
<tr class="separator:a3db8c15289fa7a842c42b2845aba2fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab77d69edd95c98820b1dbc8ad6c31665">static_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab77d69edd95c98820b1dbc8ad6c31665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a static_cast expression.  <a href="#ab77d69edd95c98820b1dbc8ad6c31665">More...</a><br /></td></tr>
<tr class="separator:ab77d69edd95c98820b1dbc8ad6c31665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a4858bfccdab81ea8693887119371"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a491a4858bfccdab81ea8693887119371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a491a4858bfccdab81ea8693887119371">dynamic_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a491a4858bfccdab81ea8693887119371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a dynamic_cast expression.  <a href="#a491a4858bfccdab81ea8693887119371">More...</a><br /></td></tr>
<tr class="separator:a491a4858bfccdab81ea8693887119371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c7042d950278a26182ff742e9d0046"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a29c7042d950278a26182ff742e9d0046"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a29c7042d950278a26182ff742e9d0046">const_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a29c7042d950278a26182ff742e9d0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a const_cast expression.  <a href="#a29c7042d950278a26182ff742e9d0046">More...</a><br /></td></tr>
<tr class="separator:a29c7042d950278a26182ff742e9d0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec28839a72be32c0258b7d60a29b8c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a32ec28839a72be32c0258b7d60a29b8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a32ec28839a72be32c0258b7d60a29b8c">reinterpret_pointer_cast</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;r) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a32ec28839a72be32c0258b7d60a29b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a reinterpret_cast expression.  <a href="#a32ec28839a72be32c0258b7d60a29b8c">More...</a><br /></td></tr>
<tr class="separator:a32ec28839a72be32c0258b7d60a29b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memTemplParams" colspan="2">template&lt;class Deleter , class T &gt; </td></tr>
<tr class="memitem:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memTemplItemLeft" align="right" valign="top">Deleter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5255215e28b4b2bb9fbee46d1d0ccd0a">get_deleter</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;p) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the p's deleter.  <a href="#a5255215e28b4b2bb9fbee46d1d0ccd0a">More...</a><br /></td></tr>
<tr class="separator:a5255215e28b4b2bb9fbee46d1d0ccd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d2f4cf39bad33572029090b20db719"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a84d2f4cf39bad33572029090b20db719"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a84d2f4cf39bad33572029090b20db719">operator==</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a84d2f4cf39bad33572029090b20db719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#a84d2f4cf39bad33572029090b20db719">More...</a><br /></td></tr>
<tr class="separator:a84d2f4cf39bad33572029090b20db719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165ff90955a23e1f59be60117d8fb6d8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a165ff90955a23e1f59be60117d8fb6d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a165ff90955a23e1f59be60117d8fb6d8">operator!=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a165ff90955a23e1f59be60117d8fb6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#a165ff90955a23e1f59be60117d8fb6d8">More...</a><br /></td></tr>
<tr class="separator:a165ff90955a23e1f59be60117d8fb6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5a5fcd7bcea837df91a3a8d7af4fa4b3">operator&lt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#a5a5fcd7bcea837df91a3a8d7af4fa4b3">More...</a><br /></td></tr>
<tr class="separator:a5a5fcd7bcea837df91a3a8d7af4fa4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aba1be6682696149a335eb589aa362"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a83aba1be6682696149a335eb589aa362"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a83aba1be6682696149a335eb589aa362">operator&gt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a83aba1be6682696149a335eb589aa362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#a83aba1be6682696149a335eb589aa362">More...</a><br /></td></tr>
<tr class="separator:a83aba1be6682696149a335eb589aa362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f644b2732c39647a76af4d83c5152e"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a55f644b2732c39647a76af4d83c5152e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a55f644b2732c39647a76af4d83c5152e">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a55f644b2732c39647a76af4d83c5152e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#a55f644b2732c39647a76af4d83c5152e">More...</a><br /></td></tr>
<tr class="separator:a55f644b2732c39647a76af4d83c5152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad61f697dbd6cd60ea037b3d7ef765781">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad61f697dbd6cd60ea037b3d7ef765781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects.  <a href="#ad61f697dbd6cd60ea037b3d7ef765781">More...</a><br /></td></tr>
<tr class="separator:ad61f697dbd6cd60ea037b3d7ef765781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf90c9ead79e01fd50379106f306948f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf90c9ead79e01fd50379106f306948f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#acf90c9ead79e01fd50379106f306948f">operator==</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf90c9ead79e01fd50379106f306948f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#acf90c9ead79e01fd50379106f306948f">More...</a><br /></td></tr>
<tr class="separator:acf90c9ead79e01fd50379106f306948f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717cdfe407e14c88b05176954f851176"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a717cdfe407e14c88b05176954f851176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a717cdfe407e14c88b05176954f851176">operator==</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a717cdfe407e14c88b05176954f851176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a717cdfe407e14c88b05176954f851176">More...</a><br /></td></tr>
<tr class="separator:a717cdfe407e14c88b05176954f851176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a0395e3e9d88a2b48ffed79cacc16b47b">operator!=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a0395e3e9d88a2b48ffed79cacc16b47b">More...</a><br /></td></tr>
<tr class="separator:a0395e3e9d88a2b48ffed79cacc16b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac0ed2c87317a0797e419c4a799be22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ac0ed2c87317a0797e419c4a799be22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2ac0ed2c87317a0797e419c4a799be22">operator!=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ac0ed2c87317a0797e419c4a799be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a2ac0ed2c87317a0797e419c4a799be22">More...</a><br /></td></tr>
<tr class="separator:a2ac0ed2c87317a0797e419c4a799be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada51131a06c891299eaf3393b9e0febe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada51131a06c891299eaf3393b9e0febe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ada51131a06c891299eaf3393b9e0febe">operator&lt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ada51131a06c891299eaf3393b9e0febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#ada51131a06c891299eaf3393b9e0febe">More...</a><br /></td></tr>
<tr class="separator:ada51131a06c891299eaf3393b9e0febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3a8e5386ada06bb6aadcf89618b6403a">operator&lt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a8e5386ada06bb6aadcf89618b6403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a3a8e5386ada06bb6aadcf89618b6403a">More...</a><br /></td></tr>
<tr class="separator:a3a8e5386ada06bb6aadcf89618b6403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5509a8ce6353c8143340e9f90612ef2d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5509a8ce6353c8143340e9f90612ef2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5509a8ce6353c8143340e9f90612ef2d">operator&gt;</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5509a8ce6353c8143340e9f90612ef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a5509a8ce6353c8143340e9f90612ef2d">More...</a><br /></td></tr>
<tr class="separator:a5509a8ce6353c8143340e9f90612ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5a31a9fef43360d2fd1390eefd98aa44">operator&gt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5a31a9fef43360d2fd1390eefd98aa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a5a31a9fef43360d2fd1390eefd98aa44">More...</a><br /></td></tr>
<tr class="separator:a5a31a9fef43360d2fd1390eefd98aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe304e6d2e73044323e8674f05f0b2c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abfe304e6d2e73044323e8674f05f0b2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#abfe304e6d2e73044323e8674f05f0b2c">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:abfe304e6d2e73044323e8674f05f0b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#abfe304e6d2e73044323e8674f05f0b2c">More...</a><br /></td></tr>
<tr class="separator:abfe304e6d2e73044323e8674f05f0b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b716518505c9332d6cf76df98e883"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c4b716518505c9332d6cf76df98e883"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3c4b716518505c9332d6cf76df98e883">operator&lt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3c4b716518505c9332d6cf76df98e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a3c4b716518505c9332d6cf76df98e883">More...</a><br /></td></tr>
<tr class="separator:a3c4b716518505c9332d6cf76df98e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc0a95868e5576296d1b22d19fece8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1bc0a95868e5576296d1b22d19fece8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad1bc0a95868e5576296d1b22d19fece8">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1bc0a95868e5576296d1b22d19fece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#ad1bc0a95868e5576296d1b22d19fece8">More...</a><br /></td></tr>
<tr class="separator:ad1bc0a95868e5576296d1b22d19fece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a8e32eec1fa39c291d06fb43e1f70915b">operator&gt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8e32eec1fa39c291d06fb43e1f70915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer.  <a href="#a8e32eec1fa39c291d06fb43e1f70915b">More...</a><br /></td></tr>
<tr class="separator:a8e32eec1fa39c291d06fb43e1f70915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1c502701c9ac87b6403b3ed3374538"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:a6b1c502701c9ac87b6403b3ed3374538"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6b1c502701c9ac87b6403b3ed3374538">operator&lt;&lt;</a> (std::basic_ostream&lt; U, V &gt; &amp;os, const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a6b1c502701c9ac87b6403b3ed3374538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the value of the pointer stored in ptr into the output stream os.  <a href="#a6b1c502701c9ac87b6403b3ed3374538">More...</a><br /></td></tr>
<tr class="separator:a6b1c502701c9ac87b6403b3ed3374538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">atomic_is_lock_free</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; const *p)</td></tr>
<tr class="memdesc:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether atomic access to the shared pointer pointed-to by p is lock-free.  <a href="#a6df8cc4c1a8c526fd69a1faa328e1781">More...</a><br /></td></tr>
<tr class="separator:a6df8cc4c1a8c526fd69a1faa328e1781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e269c7e54c8d1a971177e9765fb31c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a58e269c7e54c8d1a971177e9765fb31c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">atomic_load</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p)</td></tr>
<tr class="memdesc:a58e269c7e54c8d1a971177e9765fb31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst)  <a href="#a58e269c7e54c8d1a971177e9765fb31c">More...</a><br /></td></tr>
<tr class="separator:a58e269c7e54c8d1a971177e9765fb31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124bdb97e54c1920a360638dad128ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af124bdb97e54c1920a360638dad128ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">atomic_load_explicit</a> (const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, std::memory_order mo)</td></tr>
<tr class="memdesc:af124bdb97e54c1920a360638dad128ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shared pointer pointed-to by p.  <a href="#af124bdb97e54c1920a360638dad128ec">More...</a><br /></td></tr>
<tr class="separator:af124bdb97e54c1920a360638dad128ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db0aae6446352c8293d7770e70dfd04"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5db0aae6446352c8293d7770e70dfd04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">atomic_store</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r)</td></tr>
<tr class="memdesc:a5db0aae6446352c8293d7770e70dfd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst)  <a href="#a5db0aae6446352c8293d7770e70dfd04">More...</a><br /></td></tr>
<tr class="separator:a5db0aae6446352c8293d7770e70dfd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe627ff91ab06f577d6d7cf94fa94037"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afe627ff91ab06f577d6d7cf94fa94037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">atomic_store_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r, std::memory_order mo)</td></tr>
<tr class="memdesc:afe627ff91ab06f577d6d7cf94fa94037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p-&gt;swap(r).  <a href="#afe627ff91ab06f577d6d7cf94fa94037">More...</a><br /></td></tr>
<tr class="separator:afe627ff91ab06f577d6d7cf94fa94037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d928899e10f34e68868a8d33fbab2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff1d928899e10f34e68868a8d33fbab2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">atomic_exchange</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r)</td></tr>
<tr class="memdesc:aff1d928899e10f34e68868a8d33fbab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_exchange(p, r, memory_order_seq_cst)  <a href="#aff1d928899e10f34e68868a8d33fbab2">More...</a><br /></td></tr>
<tr class="separator:aff1d928899e10f34e68868a8d33fbab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6208465729923d0056ede4ed72e57a7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6208465729923d0056ede4ed72e57a7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">atomic_exchange_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; r, std::memory_order mo)</td></tr>
<tr class="memdesc:a6208465729923d0056ede4ed72e57a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly pointed-to by p, atomically.  <a href="#a6208465729923d0056ede4ed72e57a7b">More...</a><br /></td></tr>
<tr class="separator:a6208465729923d0056ede4ed72e57a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dc503001ad62be233dac0a07a49fee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a25dc503001ad62be233dac0a07a49fee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">atomic_compare_exchange_weak</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired)</td></tr>
<tr class="memdesc:a25dc503001ad62be233dac0a07a49fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst)  <a href="#a25dc503001ad62be233dac0a07a49fee">More...</a><br /></td></tr>
<tr class="separator:a25dc503001ad62be233dac0a07a49fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">atomic_compare_exchange_strong</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired)</td></tr>
<tr class="memdesc:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst)  <a href="#aaad0d590db4d1724fd0c21e0f0efedeb">More...</a><br /></td></tr>
<tr class="separator:aaad0d590db4d1724fd0c21e0f0efedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">atomic_compare_exchange_strong_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</td></tr>
<tr class="memdesc:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false.  <a href="#ae8f7dfcc23277f4c5dd0d9e22e634076">More...</a><br /></td></tr>
<tr class="separator:ae8f7dfcc23277f4c5dd0d9e22e634076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">atomic_compare_exchange_weak_explicit</a> (<a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *p, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *expected, <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</td></tr>
<tr class="memdesc:a9189fc5561dbe027149aa1d43f1c3e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false, but may fail spuriously.  <a href="#a9189fc5561dbe027149aa1d43f1c3e00">More...</a><br /></td></tr>
<tr class="separator:a9189fc5561dbe027149aa1d43f1c3e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a3b16a5f9ca990313f55d3e7e97f5f6ce">make_unique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of non-array type T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> using args as the parameter list for the constructor of T.  <a href="#a3b16a5f9ca990313f55d3e7e97f5f6ce">More...</a><br /></td></tr>
<tr class="separator:a3b16a5f9ca990313f55d3e7e97f5f6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d34307ba83e132a382776a7f85288d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a54d34307ba83e132a382776a7f85288d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Unknown_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a54d34307ba83e132a382776a7f85288d">make_unique</a> (size_t n)</td></tr>
<tr class="memdesc:a54d34307ba83e132a382776a7f85288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array of unknown bound T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>.  <a href="#a54d34307ba83e132a382776a7f85288d">More...</a><br /></td></tr>
<tr class="separator:a54d34307ba83e132a382776a7f85288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt; T &gt;::_Known_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ad84d4f349c97d7ef4dc4cb7165bccc68">make_unique</a> (Args &amp;&amp;...)=delete</td></tr>
<tr class="memdesc:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of arrays of known bound is disallowed.  <a href="#ad84d4f349c97d7ef4dc4cb7165bccc68">More...</a><br /></td></tr>
<tr class="separator:ad84d4f349c97d7ef4dc4cb7165bccc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27302980c01b6af6b48aec2f7e6a961a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a27302980c01b6af6b48aec2f7e6a961a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a27302980c01b6af6b48aec2f7e6a961a">operator==</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a27302980c01b6af6b48aec2f7e6a961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a27302980c01b6af6b48aec2f7e6a961a">More...</a><br /></td></tr>
<tr class="separator:a27302980c01b6af6b48aec2f7e6a961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ab8f93c25e87c9185589c8c8cecd7f271">operator!=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab8f93c25e87c9185589c8c8cecd7f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#ab8f93c25e87c9185589c8c8cecd7f271">More...</a><br /></td></tr>
<tr class="separator:ab8f93c25e87c9185589c8c8cecd7f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302436b7f0fe243a2c1792b37dc096fa"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a302436b7f0fe243a2c1792b37dc096fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a302436b7f0fe243a2c1792b37dc096fa">operator&lt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a302436b7f0fe243a2c1792b37dc096fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a302436b7f0fe243a2c1792b37dc096fa">More...</a><br /></td></tr>
<tr class="separator:a302436b7f0fe243a2c1792b37dc096fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94436f6eb9da1991d95771b51958c2a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:ac94436f6eb9da1991d95771b51958c2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#ac94436f6eb9da1991d95771b51958c2a">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac94436f6eb9da1991d95771b51958c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#ac94436f6eb9da1991d95771b51958c2a">More...</a><br /></td></tr>
<tr class="separator:ac94436f6eb9da1991d95771b51958c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee6a539d3b600aa8fec1b928abed915"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a5ee6a539d3b600aa8fec1b928abed915"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5ee6a539d3b600aa8fec1b928abed915">operator&gt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5ee6a539d3b600aa8fec1b928abed915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a5ee6a539d3b600aa8fec1b928abed915">More...</a><br /></td></tr>
<tr class="separator:a5ee6a539d3b600aa8fec1b928abed915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class D1 , class T2 , class D2 &gt; </td></tr>
<tr class="memitem:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a0974a3f27e1618c8465caadf6f6bda3a">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0974a3f27e1618c8465caadf6f6bda3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects.  <a href="#a0974a3f27e1618c8465caadf6f6bda3a">More...</a><br /></td></tr>
<tr class="separator:a0974a3f27e1618c8465caadf6f6bda3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b9419192adc27bb8a8506122b1f0d5"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a46b9419192adc27bb8a8506122b1f0d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a46b9419192adc27bb8a8506122b1f0d5">operator==</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a46b9419192adc27bb8a8506122b1f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a46b9419192adc27bb8a8506122b1f0d5">More...</a><br /></td></tr>
<tr class="separator:a46b9419192adc27bb8a8506122b1f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a04c9545fb0dcbb28d724f508d7e042b7">operator==</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04c9545fb0dcbb28d724f508d7e042b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a04c9545fb0dcbb28d724f508d7e042b7">More...</a><br /></td></tr>
<tr class="separator:a04c9545fb0dcbb28d724f508d7e042b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e62c6df7d6956d39b91807898912120"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a9e62c6df7d6956d39b91807898912120"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a9e62c6df7d6956d39b91807898912120">operator!=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9e62c6df7d6956d39b91807898912120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a9e62c6df7d6956d39b91807898912120">More...</a><br /></td></tr>
<tr class="separator:a9e62c6df7d6956d39b91807898912120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679fdd252caae096dd6d71b192564fb0"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a679fdd252caae096dd6d71b192564fb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a679fdd252caae096dd6d71b192564fb0">operator!=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:a679fdd252caae096dd6d71b192564fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a679fdd252caae096dd6d71b192564fb0">More...</a><br /></td></tr>
<tr class="separator:a679fdd252caae096dd6d71b192564fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#adbaed90b4b8e62cef2fdd4428acfa840">operator&lt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:adbaed90b4b8e62cef2fdd4428acfa840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#adbaed90b4b8e62cef2fdd4428acfa840">More...</a><br /></td></tr>
<tr class="separator:adbaed90b4b8e62cef2fdd4428acfa840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358041bb7ae757f06ce0849208bb2ed"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a2358041bb7ae757f06ce0849208bb2ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2358041bb7ae757f06ce0849208bb2ed">operator&lt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2358041bb7ae757f06ce0849208bb2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a2358041bb7ae757f06ce0849208bb2ed">More...</a><br /></td></tr>
<tr class="separator:a2358041bb7ae757f06ce0849208bb2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6448b3a2571d02388459c38014c3e85d"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a6448b3a2571d02388459c38014c3e85d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a6448b3a2571d02388459c38014c3e85d">operator&lt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:a6448b3a2571d02388459c38014c3e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a6448b3a2571d02388459c38014c3e85d">More...</a><br /></td></tr>
<tr class="separator:a6448b3a2571d02388459c38014c3e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa527891d4d0d1578e944c245db5344"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a5fa527891d4d0d1578e944c245db5344"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a5fa527891d4d0d1578e944c245db5344">operator&lt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5fa527891d4d0d1578e944c245db5344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a5fa527891d4d0d1578e944c245db5344">More...</a><br /></td></tr>
<tr class="separator:a5fa527891d4d0d1578e944c245db5344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a51282cc1ffc3a25f8b87771ee73111e7">operator&gt;</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:a51282cc1ffc3a25f8b87771ee73111e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a51282cc1ffc3a25f8b87771ee73111e7">More...</a><br /></td></tr>
<tr class="separator:a51282cc1ffc3a25f8b87771ee73111e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20c90d8238abbfc43c58847d16d29e"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:a2d20c90d8238abbfc43c58847d16d29e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#a2d20c90d8238abbfc43c58847d16d29e">operator&gt;</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2d20c90d8238abbfc43c58847d16d29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#a2d20c90d8238abbfc43c58847d16d29e">More...</a><br /></td></tr>
<tr class="separator:a2d20c90d8238abbfc43c58847d16d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c13caed76fa587fe35ab57dda17c4"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:aac1c13caed76fa587fe35ab57dda17c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aac1c13caed76fa587fe35ab57dda17c4">operator&gt;=</a> (const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;lhs, std::nullptr_t rhs)</td></tr>
<tr class="memdesc:aac1c13caed76fa587fe35ab57dda17c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#aac1c13caed76fa587fe35ab57dda17c4">More...</a><br /></td></tr>
<tr class="separator:aac1c13caed76fa587fe35ab57dda17c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr class="memitem:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aa1a2bf209ee2771fb4ea401c297d56c6">operator&gt;=</a> (std::nullptr_t lhs, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer.  <a href="#aa1a2bf209ee2771fb4ea401c297d56c6">More...</a><br /></td></tr>
<tr class="separator:aa1a2bf209ee2771fb4ea401c297d56c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecd94b4b26224031f43e39a282a74b7"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Y , class D &gt; </td></tr>
<tr class="memitem:adecd94b4b26224031f43e39a282a74b7"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#adecd94b4b26224031f43e39a282a74b7">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; Y, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:adecd94b4b26224031f43e39a282a74b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the value of the pointer stored in ptr into the output stream os.  <a href="#adecd94b4b26224031f43e39a282a74b7">More...</a><br /></td></tr>
<tr class="separator:adecd94b4b26224031f43e39a282a74b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">swap</a> (<a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;rhs) <a class="el" href="compiler__checks_8hpp.html#a2998db45be168f991e952469f9789ac6">TSP_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>.  <a href="#aa33cc870cf4266ac52c8fb07a295bbeb">More...</a><br /></td></tr>
<tr class="separator:aa33cc870cf4266ac52c8fb07a295bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3db8c15289fa7a842c42b2845aba2fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db8c15289fa7a842c42b2845aba2fc0">&#9670;&nbsp;</a></span>allocate_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>The object is constructed as if by the expression std::allocator_traits&lt;A2&gt;::construct(a, pv, v)), where pv is an internal void* pointer to storage suitable to hold an object of type T and a is the possibly-rebound copy of the allocator.</p>
<p>The storage is typically larger than sizeof(T) in order to use one allocation for both the control block of the shared pointer and the T object.</p>
<p>The <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> constructor called by this function enables shared_from_this with a pointer to the newly constructed object of type T.</p>
<p>All memory allocation is done using a copy of alloc, which must satisfy the Allocator requirements.</p>
<p>This overload only participates in overload resolution if T is not an array type </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00535">535</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                                                                   {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(std::move(</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            std::allocate_shared&lt;T&gt;(alloc, std::forward&lt;Args&gt;(args)...)));</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaad0d590db4d1724fd0c21e0f0efedeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad0d590db4d1724fd0c21e0f0efedeb">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00875">875</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                                                           {</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">atomic_compare_exchange_strong</a>(</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            desired.get_std_shared_ptr());</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_aaad0d590db4d1724fd0c21e0f0efedeb"><div class="ttname"><a href="namespacethrowing.html#aaad0d590db4d1724fd0c21e0f0efedeb">throwing::atomic_compare_exchange_strong</a></div><div class="ttdeci">bool atomic_compare_exchange_strong(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired)</div><div class="ttdoc">Equivalent to atomic_compare_exchange_strong_explicit(p, expected, desired, std::memory_order_seq_cst...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00875">shared_ptr.hpp:875</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8f7dfcc23277f4c5dd0d9e22e634076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f7dfcc23277f4c5dd0d9e22e634076">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_strong_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00891">891</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                                                                      {</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">atomic_compare_exchange_strong_explicit</a>(</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;            desired.get_std_shared_ptr(), success, failure);</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_ae8f7dfcc23277f4c5dd0d9e22e634076"><div class="ttname"><a href="namespacethrowing.html#ae8f7dfcc23277f4c5dd0d9e22e634076">throwing::atomic_compare_exchange_strong_explicit</a></div><div class="ttdeci">bool atomic_compare_exchange_strong_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</div><div class="ttdoc">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same poi...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00891">shared_ptr.hpp:891</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a25dc503001ad62be233dac0a07a49fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dc503001ad62be233dac0a07a49fee">&#9670;&nbsp;</a></span>atomic_compare_exchange_weak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_weak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00863">863</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                                                         {</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">atomic_compare_exchange_weak</a>(</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            desired.get_std_shared_ptr());</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a25dc503001ad62be233dac0a07a49fee"><div class="ttname"><a href="namespacethrowing.html#a25dc503001ad62be233dac0a07a49fee">throwing::atomic_compare_exchange_weak</a></div><div class="ttdeci">bool atomic_compare_exchange_weak(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired)</div><div class="ttdoc">Equivalent to atomic_compare_exchange_weak_explicit(p, expected, desired, std::memory_order_seq_cst, std::memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00863">shared_ptr.hpp:863</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9189fc5561dbe027149aa1d43f1c3e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9189fc5561dbe027149aa1d43f1c3e00">&#9670;&nbsp;</a></span>atomic_compare_exchange_weak_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_compare_exchange_weak_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns desired into *p using the memory ordering constraints specified by success and returns true. If they are not equivalent, assigns *p into *expected using the memory ordering constraints specified by failure and returns false, but may fail spuriously. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00910">910</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                                                                    {</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">atomic_compare_exchange_weak_explicit</a>(</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(expected),</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;            desired.get_std_shared_ptr(), success, failure);</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a9189fc5561dbe027149aa1d43f1c3e00"><div class="ttname"><a href="namespacethrowing.html#a9189fc5561dbe027149aa1d43f1c3e00">throwing::atomic_compare_exchange_weak_explicit</a></div><div class="ttdeci">bool atomic_compare_exchange_weak_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; *expected, shared_ptr&lt; T &gt; desired, std::memory_order success, std::memory_order failure)</div><div class="ttdoc">Compares the shared pointers pointed-to by p and expected. If they are equivalent (store the same poi...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00910">shared_ptr.hpp:910</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff1d928899e10f34e68868a8d33fbab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1d928899e10f34e68868a8d33fbab2">&#9670;&nbsp;</a></span>atomic_exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_exchange(p, r, memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00841">841</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                                                                 {</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    <span class="keywordflow">return</span> std::move(<a class="code" href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">atomic_exchange</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                                     r.get_std_shared_ptr()));</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_aff1d928899e10f34e68868a8d33fbab2"><div class="ttname"><a href="namespacethrowing.html#aff1d928899e10f34e68868a8d33fbab2">throwing::atomic_exchange</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_exchange(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r)</div><div class="ttdoc">Equivalent to atomic_exchange(p, r, memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00841">shared_ptr.hpp:841</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6208465729923d0056ede4ed72e57a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6208465729923d0056ede4ed72e57a7b">&#9670;&nbsp;</a></span>atomic_exchange_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_exchange_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly pointed-to by p, atomically. </p>
<p>Effectively executes p-&gt;swap(r) and returns a copy of r after the swap. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00852">852</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                                                           {</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="keywordflow">return</span> std::move(</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;            <a class="code" href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">atomic_exchange_explicit</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                                     r.get_std_shared_ptr(), mo));</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a6208465729923d0056ede4ed72e57a7b"><div class="ttname"><a href="namespacethrowing.html#a6208465729923d0056ede4ed72e57a7b">throwing::atomic_exchange_explicit</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_exchange_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r, std::memory_order mo)</div><div class="ttdoc">Stores the shared pointer r in the shared pointer pointed to by p and returns the value formerly poin...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00852">shared_ptr.hpp:852</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6df8cc4c1a8c526fd69a1faa328e1781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df8cc4c1a8c526fd69a1faa328e1781">&#9670;&nbsp;</a></span>atomic_is_lock_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::atomic_is_lock_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether atomic access to the shared pointer pointed-to by p is lock-free. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00795">795</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                                                                    {</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">atomic_is_lock_free</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; <span class="keyword">const </span>*<span class="keyword">&gt;</span>(p));</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a6df8cc4c1a8c526fd69a1faa328e1781"><div class="ttname"><a href="namespacethrowing.html#a6df8cc4c1a8c526fd69a1faa328e1781">throwing::atomic_is_lock_free</a></div><div class="ttdeci">bool atomic_is_lock_free(shared_ptr&lt; T &gt; const *p)</div><div class="ttdoc">Determines whether atomic access to the shared pointer pointed-to by p is lock-free. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00795">shared_ptr.hpp:795</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a58e269c7e54c8d1a971177e9765fb31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e269c7e54c8d1a971177e9765fb31c">&#9670;&nbsp;</a></span>atomic_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00801">801</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                                                                     {</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    <span class="keywordflow">return</span> std::move(</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;            <a class="code" href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">atomic_load</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p)));</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a58e269c7e54c8d1a971177e9765fb31c"><div class="ttname"><a href="namespacethrowing.html#a58e269c7e54c8d1a971177e9765fb31c">throwing::atomic_load</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_load(const shared_ptr&lt; T &gt; *p)</div><div class="ttdoc">Equivalent to atomic_load_explicit(p, std::memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00801">shared_ptr.hpp:801</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af124bdb97e54c1920a360638dad128ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af124bdb97e54c1920a360638dad128ec">&#9670;&nbsp;</a></span>atomic_load_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shared pointer pointed-to by p. </p>
<p>As with the non-specialized std::atomic_load_explicit, mo cannot be std::memory_order_release or std::memory_order_acq_rel </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00812">812</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                                                       {</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    <span class="keywordflow">return</span> std::move(<a class="code" href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">atomic_load_explicit</a>(</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p), mo));</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_af124bdb97e54c1920a360638dad128ec"><div class="ttname"><a href="namespacethrowing.html#af124bdb97e54c1920a360638dad128ec">throwing::atomic_load_explicit</a></div><div class="ttdeci">shared_ptr&lt; T &gt; atomic_load_explicit(const shared_ptr&lt; T &gt; *p, std::memory_order mo)</div><div class="ttdoc">Returns the shared pointer pointed-to by p. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00812">shared_ptr.hpp:812</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5db0aae6446352c8293d7770e70dfd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db0aae6446352c8293d7770e70dfd04">&#9670;&nbsp;</a></span>atomic_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::atomic_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst) </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00820">820</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                                                                        {</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    <a class="code" href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">atomic_store</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                 r.get_std_shared_ptr());</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_a5db0aae6446352c8293d7770e70dfd04"><div class="ttname"><a href="namespacethrowing.html#a5db0aae6446352c8293d7770e70dfd04">throwing::atomic_store</a></div><div class="ttdeci">void atomic_store(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r)</div><div class="ttdoc">Equivalent to atomic_store_explicit(p, r, memory_order_seq_cst) </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00820">shared_ptr.hpp:820</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afe627ff91ab06f577d6d7cf94fa94037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe627ff91ab06f577d6d7cf94fa94037">&#9670;&nbsp;</a></span>atomic_store_explicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::memory_order&#160;</td>
          <td class="paramname"><em>mo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p-&gt;swap(r). </p>
<p>As with the non-specialized std::atomic_store_explicit, mo cannot be std::memory_order_acquire or std::memory_order_acq_rel. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00832">832</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                                               {</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;    <a class="code" href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">atomic_store_explicit</a>(<span class="keyword">reinterpret_cast&lt;</span>std::shared_ptr&lt;T&gt; *<span class="keyword">&gt;</span>(p),</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                          r.get_std_shared_ptr(), mo);</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;}</div><div class="ttc" id="namespacethrowing_html_afe627ff91ab06f577d6d7cf94fa94037"><div class="ttname"><a href="namespacethrowing.html#afe627ff91ab06f577d6d7cf94fa94037">throwing::atomic_store_explicit</a></div><div class="ttdeci">void atomic_store_explicit(shared_ptr&lt; T &gt; *p, shared_ptr&lt; T &gt; r, std::memory_order mo)</div><div class="ttdoc">Stores the shared pointer r in the shared pointer pointed-to by p atomically, effectively executing p...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00832">shared_ptr.hpp:832</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a29c7042d950278a26182ff742e9d0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c7042d950278a26182ff742e9d0046">&#9670;&nbsp;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a const_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless const_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00590">590</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                                                                      {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">const_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a491a4858bfccdab81ea8693887119371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a4858bfccdab81ea8693887119371">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a dynamic_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> will share ownership with r, except that it is empty if the dynamic_cast performed by dynamic_pointer_cast returns a null pointer.</p>
<p>The behavior is undefined unless dynamic_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00570">570</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                                                                        {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> p =</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                <span class="keyword">dynamic_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get())) {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="keywordflow">return</span> shared_ptr&lt;T&gt;();</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    }</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5255215e28b4b2bb9fbee46d1d0ccd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255215e28b4b2bb9fbee46d1d0ccd0a">&#9670;&nbsp;</a></span>get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Deleter , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Deleter* throwing::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to the p's deleter. </p>
<p>If the shared pointer p owns a deleter of type cv-unqualified Deleter (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00620">620</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                                                          {</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="keywordflow">return</span> std::get_deleter&lt;Deleter&gt;(p.get_std_shared_ptr());</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaff10629d166d6ded4d90ed20000dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff10629d166d6ded4d90ed20000dc62">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::make_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in a <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>The object is constructed as if by the expression ::new (pv) T(std::forward&lt;Args&gt;(args)...), where pv is an internal void* pointer to storage suitable to hold an object of type T.</p>
<p>The storage is typically larger than sizeof(T) in order to use one allocation for both the control block of the shared pointer and the T object.</p>
<p>The <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> constructor called by this function enables shared_from_this with a pointer to the newly constructed object of type T.</p>
<p>This overload only participates in overload resolution if T is not an array type </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00509">509</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                                                                             {</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            std::move(std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...)));</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3b16a5f9ca990313f55d3e7e97f5f6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b16a5f9ca990313f55d3e7e97f5f6ce">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Single_object throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of non-array type T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a> using args as the parameter list for the constructor of T. </p>
<p>Equivalent to: unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))</p>
<p>This overload only participates in overload resolution if T is not an array type. </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00582">582</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                                                                        {</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keywordflow">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...));</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a54d34307ba83e132a382776a7f85288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d34307ba83e132a382776a7f85288d">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Unknown_bound throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an array of unknown bound T and wraps it in a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>. </p>
<p>Equivalent to: unique_ptr&lt;T&gt;(new typename std::remove_extent&lt;T&gt;::type[size]())</p>
<p>This overload only participates in overload resolution if T is an array of unknown bound. </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00596">596</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                                                                 {</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_extent&lt;T&gt;::type U;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">return</span> unique_ptr&lt;T&gt;(<span class="keyword">new</span> U[n]());</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad84d4f349c97d7ef4dc4cb7165bccc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84d4f349c97d7ef4dc4cb7165bccc68">&#9670;&nbsp;</a></span>make_unique() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthrowing_1_1detail_1_1___unique__if.html">detail::_Unique_if</a>&lt;T&gt;::_Known_bound throwing::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction of arrays of known bound is disallowed. </p>

</div>
</div>
<a id="ab8f93c25e87c9185589c8c8cecd7f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f93c25e87c9185589c8c8cecd7f271">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs.get() == rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00618">618</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                                                                              {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() != rhs.get_std_unique_ptr();</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a165ff90955a23e1f59be60117d8fb6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165ff90955a23e1f59be60117d8fb6d8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs == rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00637">637</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                                                       {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() != rhs.get_std_shared_ptr();</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9e62c6df7d6956d39b91807898912120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e62c6df7d6956d39b91807898912120">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00676">676</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                                                                            {</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() != rhs;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a679fdd252caae096dd6d71b192564fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679fdd252caae096dd6d71b192564fb0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00684">684</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                                                                            {</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_unique_ptr();</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0395e3e9d88a2b48ffed79cacc16b47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0395e3e9d88a2b48ffed79cacc16b47b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00700">700</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                                                                         {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() != rhs;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2ac0ed2c87317a0797e419c4a799be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac0ed2c87317a0797e419c4a799be22">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>(bool)rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00708">708</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                                                                         {</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keywordflow">return</span> lhs != rhs.get_std_shared_ptr();</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a302436b7f0fe243a2c1792b37dc096fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302436b7f0fe243a2c1792b37dc096fa">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;CT&gt;()(lhs.get(), rhs.get()), where CT is std::common_type&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0">unique_ptr&lt;T1, D1&gt;::pointer</a>, <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a>&lt;T2, D2&gt;::pointer&gt;::type </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00628">628</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                                                                             {</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5a5fcd7bcea837df91a3a8d7af4fa4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5fcd7bcea837df91a3a8d7af4fa4b3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;V&gt;()(lhs.get(), rhs.get()), where V is the composite pointer type of std::shared_ptr&lt;T&gt;::element_type* and std::shared_ptr&lt;U&gt;::element_type* </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00648">648</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                                                      {</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="adbaed90b4b8e62cef2fdd4428acfa840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaed90b4b8e62cef2fdd4428acfa840">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0">unique_ptr&lt;T,D&gt;::pointer</a>&gt;()(lhs.get(), nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00692">692</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                                                              {</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt; rhs;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2358041bb7ae757f06ce0849208bb2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358041bb7ae757f06ce0849208bb2ed">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1unique__ptr.html#a89116cf72b639ec131fa352662c7a8c0">unique_ptr&lt;T,D&gt;::pointer</a>&gt;()(nullptr, rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00700">700</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                                                              {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ada51131a06c891299eaf3393b9e0febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada51131a06c891299eaf3393b9e0febe">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">shared_ptr&lt;T&gt;::element_type</a>*&gt;()(lhs.get(), nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00716">716</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                                                                        {</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt; rhs;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3a8e5386ada06bb6aadcf89618b6403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e5386ada06bb6aadcf89618b6403a">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::less&lt;<a class="el" href="classthrowing_1_1shared__ptr.html#a5ae00f4f07e98dbb7c5d3cee41c95ca2">shared_ptr&lt;T&gt;::element_type</a>*&gt;()(nullptr, rhs.get()) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00724">724</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                                                                        {</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">return</span> lhs &lt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="adecd94b4b26224031f43e39a282a74b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd94b4b26224031f43e39a282a74b7">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Y , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT, Traits&gt;&amp; throwing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; Y, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the value of the pointer stored in ptr into the output stream os. </p>
<p>Equivalent to os &lt;&lt; ptr.get(). </p><dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00760">760</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                                                                             {</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    os &lt;&lt; ptr.get();</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6b1c502701c9ac87b6403b3ed3374538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1c502701c9ac87b6403b3ed3374538">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;U, V&gt;&amp; throwing::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the value of the pointer stored in ptr into the output stream os. </p>
<p>Equivalent to os &lt;&lt; ptr.get(). </p><dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00783">783</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                                                               {</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    os &lt;&lt; ptr.get();</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac94436f6eb9da1991d95771b51958c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94436f6eb9da1991d95771b51958c2a">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00636">636</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                                                                              {</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a55f644b2732c39647a76af4d83c5152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f644b2732c39647a76af4d83c5152e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00666">666</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                                                       {</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6448b3a2571d02388459c38014c3e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6448b3a2571d02388459c38014c3e85d">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00708">708</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                                                               {</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &lt;= rhs;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5fa527891d4d0d1578e944c245db5344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa527891d4d0d1578e944c245db5344">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00716">716</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                                                               {</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="abfe304e6d2e73044323e8674f05f0b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe304e6d2e73044323e8674f05f0b2c">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; lhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00748">748</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                                                                         {</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &lt;= rhs;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3c4b716518505c9332d6cf76df98e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b716518505c9332d6cf76df98e883">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(rhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00756">756</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                                                                         {</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    <span class="keywordflow">return</span> lhs &lt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a27302980c01b6af6b48aec2f7e6a961a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27302980c01b6af6b48aec2f7e6a961a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00610">610</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                                                              {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() == rhs.get_std_unique_ptr();</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a84d2f4cf39bad33572029090b20db719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d2f4cf39bad33572029090b20db719">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs.get() == rhs.get() </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00628">628</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                                                       {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() == rhs.get_std_shared_ptr();</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a46b9419192adc27bb8a8506122b1f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b9419192adc27bb8a8506122b1f0d5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00660">660</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                                                                            {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() == rhs;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a04c9545fb0dcbb28d724f508d7e042b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c9545fb0dcbb28d724f508d7e042b7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00668">668</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                                                                            {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_unique_ptr();</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="acf90c9ead79e01fd50379106f306948f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf90c9ead79e01fd50379106f306948f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00684">684</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                                                                         {</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() == rhs;</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a717cdfe407e14c88b05176954f851176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717cdfe407e14c88b05176954f851176">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00692">692</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                                                                         {</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    <span class="keywordflow">return</span> lhs == rhs.get_std_shared_ptr();</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5ee6a539d3b600aa8fec1b928abed915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee6a539d3b600aa8fec1b928abed915">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00644">644</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                                                                             {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a83aba1be6682696149a335eb589aa362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aba1be6682696149a335eb589aa362">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00657">657</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                                                      {</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a51282cc1ffc3a25f8b87771ee73111e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51282cc1ffc3a25f8b87771ee73111e7">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>nullptr &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00724">724</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                                                              {</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt; rhs;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2d20c90d8238abbfc43c58847d16d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d20c90d8238abbfc43c58847d16d29e">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; nullptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00732">732</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;                                                              {</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_unique_ptr();</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5509a8ce6353c8143340e9f90612ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5509a8ce6353c8143340e9f90612ef2d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>nullptr &lt; lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00732">732</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;                                                                        {</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt; rhs;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5a31a9fef43360d2fd1390eefd98aa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a31a9fef43360d2fd1390eefd98aa44">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>rhs &lt; nullptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00740">740</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                                                                        {</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordflow">return</span> lhs &gt; rhs.get_std_shared_ptr();</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0974a3f27e1618c8465caadf6f6bda3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0974a3f27e1618c8465caadf6f6bda3a">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class D1 , class T2 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T1, D1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00652">652</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                                                                              {</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad61f697dbd6cd60ea037b3d7ef765781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61f697dbd6cd60ea037b3d7ef765781">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00675">675</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                                                       {</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aac1c13caed76fa587fe35ab57dda17c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1c13caed76fa587fe35ab57dda17c4">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00740">740</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                                                               {</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_unique_ptr() &gt;= rhs;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa1a2bf209ee2771fb4ea401c297d56c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a2bf209ee2771fb4ea401c297d56c6">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1unique__ptr.html">unique_ptr</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">unique_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00748">748</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                                                               {</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_unique_ptr();</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad1bc0a95868e5576296d1b22d19fece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc0a95868e5576296d1b22d19fece8">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(lhs &lt; nullptr) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00764">764</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                                                                         {</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <span class="keywordflow">return</span> lhs.get_std_shared_ptr() &gt;= rhs;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8e32eec1fa39c291d06fb43e1f70915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e32eec1fa39c291d06fb43e1f70915b">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool throwing::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> with a null pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>!(nullptr &lt; rhs) </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00772">772</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                                                                         {</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keywordflow">return</span> lhs &gt;= rhs.get_std_shared_ptr();</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a32ec28839a72be32c0258b7d60a29b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ec28839a72be32c0258b7d60a29b8c">&#9670;&nbsp;</a></span>reinterpret_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a reinterpret_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless reinterpret_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00607">607</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                                                                            {</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">reinterpret_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab77d69edd95c98820b1dbc8ad6c31665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77d69edd95c98820b1dbc8ad6c31665">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt;T&gt; throwing::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> whose stored pointer is obtained from r's stored pointer using a static_cast expression. </p>
<p>If r is empty, so is the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> (but its stored pointer is not necessarily null).</p>
<p>Otherwise, the new <a class="el" href="classthrowing_1_1shared__ptr.html">shared_ptr</a> will share ownership with r.</p>
<p>The behavior is undefined unless static_cast&lt;T*&gt;((U*)nullptr) is well formed. </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00551">551</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                                                                       {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    <span class="keyword">auto</span> p = <span class="keyword">static_cast&lt;</span>typename shared_ptr&lt;T&gt;::element_type *<span class="keyword">&gt;</span>(r.get());</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keywordflow">return</span> shared_ptr&lt;T&gt;(r, p);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a881b5eadd3ef72778e6b27ffae9a62ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881b5eadd3ef72778e6b27ffae9a62ee">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1shared__ptr.html">throwing::shared_ptr</a>. </p>
<p>Swaps the pointers of lhs and rhs.</p>
<p>Calls lhs.swap(rhs). </p>

<p class="definition">Definition at line <a class="el" href="shared__ptr_8hpp_source.html#l00488">488</a> of file <a class="el" href="shared__ptr_8hpp_source.html">shared_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                                                   {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    lhs.<a class="code" href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">swap</a>(rhs);</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;}</div><div class="ttc" id="classthrowing_1_1shared__ptr_html_aad9e2abb060d2a13f3567f9ce045c153"><div class="ttname"><a href="classthrowing_1_1shared__ptr.html#aad9e2abb060d2a13f3567f9ce045c153">throwing::shared_ptr::swap</a></div><div class="ttdeci">void swap(shared_ptr &amp;r) TSP_NOEXCEPT</div><div class="ttdoc">Exchanges the contents of *this and r. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr_8hpp_source.html#l00296">shared_ptr.hpp:296</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa33cc870cf4266ac52c8fb07a295bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33cc870cf4266ac52c8fb07a295bbeb">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void throwing::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthrowing_1_1unique__ptr.html">throwing::unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specializes the std::swap algorithm for <a class="el" href="classthrowing_1_1unique__ptr.html" title="unique_ptr that manages a single object ">throwing::unique_ptr</a>. </p>
<p>Swaps the pointers of lhs and rhs.</p>
<p>Calls lhs.swap(rhs).</p>
<p>This function does not participate in overload resolution unless std::is_swappable&lt;D&gt;::value is true. (since C++17) </p>

<p class="definition">Definition at line <a class="el" href="unique__ptr_8hpp_source.html#l00775">775</a> of file <a class="el" href="unique__ptr_8hpp_source.html">unique_ptr.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                                                   {</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    <a class="code" href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">std::swap</a>(lhs.<a class="code" href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">get_std_unique_ptr</a>(), rhs.<a class="code" href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">get_std_unique_ptr</a>());</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;}</div><div class="ttc" id="classthrowing_1_1unique__ptr_html_a4ee6474d93c02bc7189a941a4a2637f1"><div class="ttname"><a href="classthrowing_1_1unique__ptr.html#a4ee6474d93c02bc7189a941a4a2637f1">throwing::unique_ptr::get_std_unique_ptr</a></div><div class="ttdeci">std_unique_ptr_type &amp; get_std_unique_ptr() TSP_NOEXCEPT</div><div class="ttdoc">Returns reference to the wrapped std::unique_ptr. </div><div class="ttdef"><b>Definition:</b> <a href="unique__ptr_8hpp_source.html#l00247">unique_ptr.hpp:247</a></div></div>
<div class="ttc" id="namespacethrowing_html_aa33cc870cf4266ac52c8fb07a295bbeb"><div class="ttname"><a href="namespacethrowing.html#aa33cc870cf4266ac52c8fb07a295bbeb">throwing::swap</a></div><div class="ttdeci">void swap(throwing::unique_ptr&lt; T &gt; &amp;lhs, throwing::unique_ptr&lt; T &gt; &amp;rhs) TSP_NOEXCEPT</div><div class="ttdoc">Specializes the std::swap algorithm for throwing::unique_ptr. </div><div class="ttdef"><b>Definition:</b> <a href="unique__ptr_8hpp_source.html#l00775">unique_ptr.hpp:775</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
